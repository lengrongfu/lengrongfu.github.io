{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2019-05-11-Introduction-to-Algorithms-lecture-7/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"67c408f7-c082-5944-8970-a3fc2cd84293","excerpt":"…","html":"<p>在实际应用中我们需要用到一种动态集合结构。散列表是普通数组的推广，可以对数组直接寻址，故可以在<code class=\"language-text\">O(1)</code>时间内访问数组的任意元素。散列表中的思想是把关键字映射到数组下标，是通过计算出来的，散列计算过程中容器出现碰撞，解决碰撞也是散列的一个难点，根本问题是哈希计算的问题。</p>\n<h1>直接访问表</h1>\n<p>当需要存储一个<code class=\"language-text\">（1.....m-1）</code>的元素时，并且<code class=\"language-text\">m</code>比较小，此时就可以用一个数组<code class=\"language-text\">T</code>来存储所有从<code class=\"language-text\">1-m</code>之间的数组。\n比如需要存储:<code class=\"language-text\">{4,6,8,3}</code>这几个元素，这里面最大的元素为<code class=\"language-text\">8</code>，所以创建一个数组有<code class=\"language-text\">8</code>个元素，把对应的元素放到数组槽里面即可。</p>\n<p>直接寻址有一个问题就是当<code class=\"language-text\">m</code>很大是，需要的数组<code class=\"language-text\">T</code>就会很大，即使需要存储的元素比较少,比如:<code class=\"language-text\">{4,1,6,2^64}</code>,这里只有四个元素，最大值为<code class=\"language-text\">2^64</code>，如果创建一个<code class=\"language-text\">T</code>的数组则需要很大的存储空间。</p>\n<h1>散列表原理和实现</h1>\n<h2>全域散列</h2>\n<h2>开放寻址法</h2>\n<h1>go map实现</h1>\n<p>golang中map是一个kv对集合。底层使用hash table，用链表来解决冲突，通过编译器配合runtime，所有的map对象都是共用一份代码。</p>\n<h2>hash 函数</h2>\n<p><code class=\"language-text\">hash</code>函数通过<code class=\"language-text\">cpu</code>的架构来选择不同的计算方式，有<code class=\"language-text\">aes</code>和<code class=\"language-text\">memhash</code>两种实现方式，<code class=\"language-text\">memhash</code>是借鉴<code class=\"language-text\">xxhash</code>和<code class=\"language-text\">cityhash</code>原理进行开发，其速度超级快，且采用的是随机哈希的方式，在每一运行过程中都有一个种子元素，同一个<code class=\"language-text\">key</code>哈希出来的值都是不一样的，这样就避免了哈希碰撞攻击，\n源码在<code class=\"language-text\">src/runtime/hase64.go</code>文件中,</p>\n<h2>解决碰撞</h2>\n<p><code class=\"language-text\">map</code>中主要通过<code class=\"language-text\">bmap</code>这个结构来存储<code class=\"language-text\">k/v</code>的,<code class=\"language-text\">bmap</code>在<code class=\"language-text\">hmap</code>中是一个动态数组，每个<code class=\"language-text\">bmap</code>对象由8个<code class=\"language-text\">k/v</code>组成，如果一个<code class=\"language-text\">bmap</code>填充满了，<code class=\"language-text\">bmap</code>中有一个指向下一个<code class=\"language-text\">bmap</code>的指针，这样就通过链表解决了冲突的情况。</p>\n<h1>参考文章</h1>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/aa0d4808cbb8\">Golang map 的底层实现</a></li>\n</ul>","frontmatter":{"title":"散列表数据结构","date":"May 11, 2019","description":null}},"previous":{"fields":{"slug":"/2019-05-07-file-save/"},"frontmatter":{"title":"文件存储系统设计"}},"next":{"fields":{"slug":"/2019-05-21-orange-原理/"},"frontmatter":{"title":"orange原理以及使用"}}},"pageContext":{"id":"67c408f7-c082-5944-8970-a3fc2cd84293","previousPostId":"5d47ad55-9e3c-58b3-a4db-40d5e5b9c664","nextPostId":"4ef3b52f-9471-530c-a843-0036dc5b2916"}},
    "staticQueryHashes": ["2841359383","3257411868"]}