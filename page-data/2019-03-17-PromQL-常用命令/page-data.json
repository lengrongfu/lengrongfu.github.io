{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2019-03-17-PromQL-常用命令/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"42a16a64-5a82-5d26-a3e9-8488edb7627b","excerpt":"PromQL…","html":"<h1>PromQL 常用命令</h1>\n<blockquote>\n<p><code class=\"language-text\">PromQL</code>可以非常方便的对监控样本数据进行统计分析，<code class=\"language-text\">PromQL</code>支持常见运算符和一些内置的函数，监控告警也是依赖<code class=\"language-text\">PromQL</code>实现的。</p>\n</blockquote>\n<h2>时间序列</h2>\n<p>在时间序列中，每一个点称之为样本，每个样本由三部分组成：</p>\n<ul>\n<li>指标：由指标名称和描述指标的级别组成的。</li>\n<li>时间戳：一个精确到毫秒级别的时间戳</li>\n<li>值：一个<code class=\"language-text\">float64</code>位的值</li>\n</ul>\n<blockquote>\n<p>&#x3C;--------------- metric --------------------->&#x3C;-timestamp ->&#x3C;-value-></p>\n<p>http_request_total{status=“200”, method=“GET”}@1434417560938 => 94355</p>\n</blockquote>\n<h3>指标</h3>\n<p>形式上所有的指标都是由如下的格式标示：</p>\n<blockquote>\n<p><metric name>{<label name>=<label value>, …}</p>\n</blockquote>\n<p>在<code class=\"language-text\">Prometheus</code>的底层实现中指标名称实际上是以<code class=\"language-text\">__name__=&lt;metric name></code>的形式保存在数据库中的。</p>\n<blockquote>\n<p>api_http_requests_total{method=“POST”, handler=“/messages”}</p>\n</blockquote>\n<p>等价于</p>\n<blockquote>\n<p>{<strong>name</strong>=“api_http_requests_total”，method=“POST”, handler=“/messages”}</p>\n</blockquote>\n<p>所以底层存储的是<code class=\"language-text\">map[string]string</code>.如下是<code class=\"language-text\">Promtheus</code>中的<code class=\"language-text\">Metric</code>的源码。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Metric LabelSet\n\n<span class=\"token keyword\">type</span> LabelSet <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span>LabelName<span class=\"token punctuation\">]</span>LabelValue\n\n<span class=\"token keyword\">type</span> LabelName <span class=\"token builtin\">string</span>\n\n<span class=\"token keyword\">type</span> LabelValue <span class=\"token builtin\">string</span></code></pre></div>\n<h3>Metric 类型</h3>\n<blockquote>\n<p>每一种指标标示的意义都不一样，因此对应的类型不一样，比如系统负载是随着时间变化而变化的值，cpu使用时间是一个一直递增的值，只要系统不重启。</p>\n</blockquote>\n<ul>\n<li>Counter：只增不减的计数器</li>\n<li>Gauge：可增可减的仪表盘</li>\n<li>Histogram和Summary分析数据分布情况 （没讲清楚）</li>\n</ul>\n<h2>初识PromQL</h2>\n<h3>运算符</h3>\n<ul>\n<li>\n<p>等于：<code class=\"language-text\">http_requests_total{instance=\"localhost:9090\"}</code></p>\n</li>\n<li>\n<p>不等于：<code class=\"language-text\">http_requests_total{instance!=\"localhost:9090\"}</code></p>\n</li>\n<li>\n<p>匹配：<code class=\"language-text\">http_requests_total{environment=~\"staging|testing|development\",method!=\"GET\"}</code> 多个值用<code class=\"language-text\">|</code>连接。</p>\n</li>\n<li>\n<p>排除：<code class=\"language-text\">http_requests_total{environment!~\"staging|testing|development\",method!=\"GET\"}</code>不存在这几个值之间。</p>\n</li>\n<li>\n<p>范围查询：<code class=\"language-text\">http_request_total{}[5m]</code> <code class=\"language-text\">5m</code>以内的数据，这叫区间数据，还有瞬时数据，只返回最近的一条<code class=\"language-text\">http_request_total{}</code>。还支持如下的时间范围查询。</p>\n<ul>\n<li>s - 秒</li>\n<li>m - 分钟</li>\n<li>h - 小时</li>\n<li>d - 天</li>\n<li>w - 周</li>\n<li>y - 年</li>\n</ul>\n</li>\n<li>\n<p>时间位移：选择一个参考点，上面的范围查询都是使用的是当前的时间值，位移操作的关键字为<code class=\"language-text\">offset</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http_request_total{} offset 5m\nhttp_request_total{}[1d] offset 1d</code></pre></div>\n</li>\n<li>\n<p>聚合操作：</p>\n<ul>\n<li><code class=\"language-text\">sum</code>函数：对指标进行求和，如：<code class=\"language-text\">sum(http_request_total)</code></li>\n<li><code class=\"language-text\">avg</code>函数：对指标进行求平均值。</li>\n</ul>\n</li>\n</ul>\n<h2>操作符</h2>\n<h3>运算符</h3>\n<ul>\n<li><code class=\"language-text\">+</code> (加法)</li>\n<li><code class=\"language-text\">-</code> (减法)</li>\n<li><code class=\"language-text\">*</code> (乘法)</li>\n<li><code class=\"language-text\">/</code> (除法)</li>\n<li><code class=\"language-text\">%</code> (求余)</li>\n<li><code class=\"language-text\">^</code> (幂运算)</li>\n</ul>\n<p>当瞬时向量与标量之间进行数学运算时，数学运算符会依次作用域瞬时向量中的每一个样本值，从而得到一组新的时间序列。如</p>\n<p><code class=\"language-text\">node_memory_free_bytes_total / (1024 * 1024)</code></p>\n<p>如果是瞬时向量与瞬时向量之间进行数学运算时，左边向量元素匹配（标签完全一致）右边向量元素，如果没找到匹配元素，则直接抛弃。如下两个指标进行相加操作，唯一不同的就是值，连时间戳都是一样的。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{device=\"sda\",instance=\"localhost:9100\",job=\"node_exporter\"}=>1634967552@1518146427.807 + 864551424@1518146427.807\n{device=\"sdb\",instance=\"localhost:9100\",job=\"node_exporter\"}=>0@1518146427.807 + 1744384@1518146427.807\n</code></pre></div>\n<h3>布尔运算</h3>\n<p>瞬时向量与标量进行布尔运算时，<code class=\"language-text\">PromQL</code>依次比较向量中的所有时间序列样本的值，如果比较结果为<code class=\"language-text\">true</code>则保留，反之丢弃。</p>\n<ul>\n<li><code class=\"language-text\">==</code> (相等)</li>\n<li><code class=\"language-text\">!=</code> (不相等)</li>\n<li><code class=\"language-text\">></code> (大于)</li>\n<li><code class=\"language-text\">&lt;</code> (小于)</li>\n<li><code class=\"language-text\">>=</code> (大于等于)</li>\n<li><code class=\"language-text\">&lt;=</code> (小于等于)</li>\n<li>瞬时向量和标量直接进行比较</li>\n</ul>\n<p><img src=\"/var/folders/rh/szl5pw3171d5x6ntky_249g80000gn/T/abnerworks.Typora/image-20190311232353111.png\" alt=\"image-20190311232353111\"></p>\n<ul>\n<li>瞬时向量和瞬时向量之间的比较</li>\n</ul>\n<p><img src=\"/var/folders/rh/szl5pw3171d5x6ntky_249g80000gn/T/abnerworks.Typora/image-20190311232718573.png\" alt=\"image-20190311232718573\"></p>\n<h3>bool 修饰符</h3>\n<p><code class=\"language-text\">bool</code>修饰符，使用<code class=\"language-text\">bool</code>修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果<code class=\"language-text\">0</code>或者<code class=\"language-text\">1</code>。从而形成一条新的时间序列.和上面的图进行对比。</p>\n<ul>\n<li>瞬时向量和标量之间比较进行<code class=\"language-text\">bool</code>修饰</li>\n</ul>\n<p><img src=\"/var/folders/rh/szl5pw3171d5x6ntky_249g80000gn/T/abnerworks.Typora/image-20190311232525778.png\" alt=\"image-20190311232525778\"></p>\n<ul>\n<li>\n<p>瞬时向量和瞬时向量之间的比较<code class=\"language-text\">bool</code>修饰</p>\n<p><img src=\"/var/folders/rh/szl5pw3171d5x6ntky_249g80000gn/T/abnerworks.Typora/image-20190311233001465.png\" alt=\"image-20190311233001465\"></p>\n</li>\n</ul>\n<h3>集合运行</h3>\n<ul>\n<li><code class=\"language-text\">and</code> (并且)</li>\n<li><code class=\"language-text\">or</code> (或者)</li>\n<li><code class=\"language-text\">unless</code> (排除)</li>\n</ul>\n<p><strong>vector1 and vector2</strong> 会产生一个由vector1的元素组成的新的向量。该向量包含vector1中完全匹配vector2中的元素组成。</p>\n<p><strong>vector1 or vector2</strong> 会产生一个新的向量，该向量包含vector1中所有的\b样本数据，以及vector2中没有与vector1匹配到的样本数据。</p>\n<p><strong>vector1 unless vector2</strong> 会产生一个新的向量，新向量中的元素由vector1中没有与vector2匹配的元素组成。</p>\n<h3>操作符优先级</h3>\n<p>如下计算每个实例上每个核心<code class=\"language-text\">cpu</code>的使用率:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token number\">100</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token function\">avg</span><span class=\"token punctuation\">(</span><span class=\"token function\">irate</span><span class=\"token punctuation\">(</span>node_cpu_seconds_total<span class=\"token punctuation\">{</span>mode<span class=\"token operator\">=</span><span class=\"token string\">\"idle\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> by <span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">,</span>cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>在PromQL操作符中优先级由高到低依次为</p>\n<ul>\n<li><code class=\"language-text\">^</code></li>\n<li><code class=\"language-text\">*, /, %</code></li>\n<li><code class=\"language-text\">+, -</code></li>\n<li><code class=\"language-text\">==, !=, &lt;=, &lt;, >=, ></code></li>\n<li><code class=\"language-text\">and, unless</code></li>\n<li><code class=\"language-text\">or</code></li>\n</ul>\n<h3>向量匹配模式详解</h3>\n<p>向量与向量之间运算时会基于默认的匹配规则，依次找到右边边向量元素和左边向量元素匹配(标签完全一致)的进行运算，不匹配则丢弃。在<code class=\"language-text\">PromQL</code>中有两种典型的匹配模式。</p>\n<h4>一对一（one to one）</h4>\n<p>一对一匹配模式会从操作符两边获取瞬时向量依次比较并找到唯一匹配的样本值，使用的表达式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">vector1 &lt;operator> vector2</code></pre></div>\n<p>在操作符两边表达式标签不一致的情况下，可以使用<code class=\"language-text\">on(label list)</code>或者<code class=\"language-text\">ignoring(label list）</code>来修改便签的匹配行为。使用<code class=\"language-text\">ignoreing</code>可以在匹配时忽略某些便签。而<code class=\"language-text\">on</code>则用于将匹配行为限定在某些便签之内。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;vector expr> &lt;bin-op> ignoring(&lt;label list>) &lt;vector expr>\n&lt;vector expr> &lt;bin-op> on(&lt;label list>) &lt;vector expr></code></pre></div>\n<p>例如当存在样本：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">method_code:http_errors:rate5m{method=\"get\", code=\"500\"}  24\nmethod_code:http_errors:rate5m{method=\"get\", code=\"404\"}  30\nmethod_code:http_errors:rate5m{method=\"put\", code=\"501\"}  3\nmethod_code:http_errors:rate5m{method=\"post\", code=\"500\"} 6\nmethod_code:http_errors:rate5m{method=\"post\", code=\"404\"} 21\n\n\nmethod:http_requests:rate5m{method=\"get\"}  600\nmethod:http_requests:rate5m{method=\"del\"}  34\nmethod:http_requests:rate5m{method=\"post\"} 120</code></pre></div>\n<p>使用PromQL表达式：使用了<code class=\"language-text\">ignoring</code>之后忽略了第一组向量的<code class=\"language-text\">code</code>标签，这样就和第二组向量拥有一样的标签了。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">method_code:http_errors:rate5m{code=\"500\"} / ignoring(code) method:http_requests:rate5m</code></pre></div>\n<p>该表达式会返回在过去5分钟内，HTTP请求状态码为<code class=\"language-text\">500</code>的在所有请求中的比例。如果没有使用<code class=\"language-text\">ignoring(code)</code>，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</p>\n<p>因此结果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{method=\"get\"}  0.04            //  24 / 600\n{method=\"post\"} 0.05            //   6 / 120</code></pre></div>\n<p>同时由于<code class=\"language-text\">method</code>为<code class=\"language-text\">put</code>和<code class=\"language-text\">del</code>的\b样本\b找不到匹配项，因此不会出现在结果当中。</p>\n<h4>多对一和一对多</h4>\n<p>多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与”多”侧的多个元素匹配的情况。在这种情况下，必须使用<code class=\"language-text\">group</code>修饰符：<code class=\"language-text\">group_left</code>或者<code class=\"language-text\">group_right</code>来确定哪一个向量具有更高的基数（充当“多”的角色）。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;vector expr> &lt;bin-op> ignoring(&lt;label list>) group_left(&lt;label list>) &lt;vector expr>\n&lt;vector expr> &lt;bin-op> ignoring(&lt;label list>) group_right(&lt;label list>) &lt;vector expr>\n&lt;vector expr> &lt;bin-op> on(&lt;label list>) group_left(&lt;label list>) &lt;vector expr>\n&lt;vector expr> &lt;bin-op> on(&lt;label list>) group_right(&lt;label list>) &lt;vector expr></code></pre></div>\n<p>多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用<code class=\"language-text\">ignoring</code>和<code class=\"language-text\">on</code>修饰符来排除或者限定匹配的标签列表。</p>\n<p>例如,使用表达式：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m</code></pre></div>\n<p>该表达式中，左向量<code class=\"language-text\">method_code:http_errors:rate5m</code>包含两个标签<code class=\"language-text\">method</code>和<code class=\"language-text\">code</code>。而右向量<code class=\"language-text\">method:http_requests:rate5m</code>中只包含一个标签<code class=\"language-text\">method</code>，因此匹配时需要使用<code class=\"language-text\">ignoring</code>限定匹配的标签为code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用<code class=\"language-text\">group</code>修饰符<code class=\"language-text\">group_left</code>指定左向量具有更好的基数。</p>\n<p>最终的运算结果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{method=\"get\", code=\"500\"}  0.04            //  24 / 600\n{method=\"get\", code=\"404\"}  0.05            //  30 / 600\n{method=\"post\", code=\"500\"} 0.05            //   6 / 120\n{method=\"post\", code=\"404\"} 0.175           //  21 / 120</code></pre></div>\n<blockquote>\n<p>提醒：<code class=\"language-text\">group</code>修饰符只能在比较和数学运算符中使用。在逻辑运算<code class=\"language-text\">and</code>,<code class=\"language-text\">unless</code>和<code class=\"language-text\">or</code>中默认与右向量中的所有元素进行匹配。</p>\n</blockquote>\n<h2>聚合操作</h2>\n<p><code class=\"language-text\">Prometheus</code>提供了一些内置的聚合操作符，这些操作符只能作用于瞬时向量，可以将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。内置的聚合函数如下：</p>\n<ul>\n<li><code class=\"language-text\">sum</code> (求和)</li>\n<li><code class=\"language-text\">min</code> (最小值)</li>\n<li><code class=\"language-text\">max</code> (最大值)</li>\n<li><code class=\"language-text\">avg</code> (平均值)</li>\n<li><code class=\"language-text\">stddev</code> (标准差)</li>\n<li><code class=\"language-text\">stdvar</code> (标准差异)</li>\n<li><code class=\"language-text\">count</code> (计数)</li>\n<li><code class=\"language-text\">count_values</code> (对value进行计数)</li>\n<li><code class=\"language-text\">bottomk</code> (后n条时序)</li>\n<li><code class=\"language-text\">topk</code> (前n条时序)</li>\n<li><code class=\"language-text\">quantile</code> (分布统计)</li>\n</ul>\n<p>使用聚合操作的语法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;aggr-op>([parameter,] &lt;vector expression>) [without|by (&lt;label list>)]</code></pre></div>\n<p>其中只有<code class=\"language-text\">count_values</code>, <code class=\"language-text\">quantile</code>, <code class=\"language-text\">topk</code>, <code class=\"language-text\">bottomk</code>支持参数(parameter)。<code class=\"language-text\">aggr-op</code>就是上面的聚合函数。</p>\n<p><code class=\"language-text\">without</code>用于移除计算结果中的标签,<code class=\"language-text\">by</code>则相反，只保留此标签。通过<code class=\"language-text\">without</code>和<code class=\"language-text\">by</code>可以按照样本的问题对数据进行聚合。</p>\n<h2>PromQL 内置函数</h2>\n<h3>计算<code class=\"language-text\">Counter</code>类型的指标增长率</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">increase(v range-vector)</code>函数：获取区间向量的增长量，</p>\n</li>\n<li>\n<p><code class=\"language-text\">rate(v range-vector)</code>函数：rate函数可以直接计算区间向量v在时间窗口内平均增长速率</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">rate(node_cpu[2m])\nincrease(node_cpu[2m]) / 120 \n上面的两个计算结果是一致的，increase(node_cpu[2m])获取的是两分钟之内的增长量，除以120s之后得到的就是两分钟之间的平均增长率。</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">irate(v range-vector)</code>函数：<code class=\"language-text\">irate</code>函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率,计算的是一个瞬时增长速率。</p>\n</li>\n</ul>\n<h3>预测Gauge指标变化趋势</h3>\n<ul>\n<li><code class=\"language-text\">predict_linear(v range-vector, t scalar)</code>函数：基于简单的线性回归的方式进行<code class=\"language-text\">t</code>秒后的<code class=\"language-text\">v</code>值的预测。</li>\n</ul>\n<h2>源码解读</h2>","frontmatter":{"title":"PromQL 常用命令","date":"March 17, 2019","description":null}},"previous":{"fields":{"slug":"/2019-03-16-Prometheus-1/"},"frontmatter":{"title":"Prometheus 初探一"}},"next":{"fields":{"slug":"/2019-03-25-Inverted-index/"},"frontmatter":{"title":"Inverted-index"}}},"pageContext":{"id":"42a16a64-5a82-5d26-a3e9-8488edb7627b","previousPostId":"6c59dc5d-837b-5596-953a-6879cf04a75f","nextPostId":"e54ec16f-0044-55cc-a261-8213f3df3076"}},
    "staticQueryHashes": ["2841359383","3257411868"]}