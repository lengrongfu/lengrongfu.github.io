{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2019-06-10-Go-bootstrap-process/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"53f9e5f2-e9fb-5a8b-87f7-7b3956772160","excerpt":"Go Bootstrap Process 一、环境准备 1、 Go版本 2、准备代码…","html":"<h1>Go Bootstrap Process</h1>\n<h2>一、环境准备</h2>\n<p>1、 Go版本</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ go version\ngo version go1.12.4 darwin/amd64</code></pre></div>\n<p>2、准备代码</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n\t<span class=\"token string\">\"fmt\"</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>3、调试工具</p>\n<p>调试工具我使用的是<code class=\"language-text\">dlv</code>，对<code class=\"language-text\">golang</code>支持最好的调试工具，比<code class=\"language-text\">gdb</code>都好，先按官方文档安装上。编译上述代码<code class=\"language-text\">go build main.go</code>,得到一个可执行文件，执行<code class=\"language-text\">dlv exec ./main</code>就进入了调试空间。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ dlv <span class=\"token builtin class-name\">exec</span> main\nType <span class=\"token string\">'help'</span> <span class=\"token keyword\">for</span> list of commands.\n<span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> </code></pre></div>\n<p>输入<code class=\"language-text\">help</code>就可以看到帮助文档，打断点以及执行下一步都是通过命令进行的，不知道就可以随时进行查看。执行上述的命令之后，程序还没有真正的启动。</p>\n<p>4、<code class=\"language-text\">dlv</code>常用的命令\n更具体的命令使用参考官方文档。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">args ：函数的参数\n<span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">(</span>alias: b<span class=\"token punctuation\">)</span> ：打一个断点\nbreakpoints <span class=\"token punctuation\">(</span>alias: bp<span class=\"token punctuation\">)</span> ：打印已经添加的断点信息。\n<span class=\"token function\">clear</span> ： 通过断点编号删除断点\n<span class=\"token builtin class-name\">continue</span> <span class=\"token punctuation\">(</span>alias: c<span class=\"token punctuation\">)</span> ：运行到有断点的地方\nlocals ：打印本地变量\nnext <span class=\"token punctuation\">(</span>alias: n<span class=\"token punctuation\">)</span> ：运行到下一行\nprint <span class=\"token punctuation\">(</span>alias: p<span class=\"token punctuation\">)</span> ：可以指定变量进行打印查看，特别对于引用类型变量最有用。\nregs ：打印当前cpu寄存器的值。\nrestart <span class=\"token punctuation\">(</span>alias: r<span class=\"token punctuation\">)</span> ：重启进程,重新开始调试.\nstack <span class=\"token punctuation\">(</span>alias: bt<span class=\"token punctuation\">)</span> ：打印堆栈信息\nstep <span class=\"token punctuation\">(</span>alias: s<span class=\"token punctuation\">)</span> ：单步执行，会进入函数内部\nstep-instruction <span class=\"token punctuation\">(</span>alias: si<span class=\"token punctuation\">)</span>  <span class=\"token builtin class-name\">:</span> cpu的单个指令执行\nthread <span class=\"token punctuation\">(</span>alias: <span class=\"token function\">tr</span><span class=\"token punctuation\">)</span> ：可以切换到指定的线程\nthreads ：打印所有线程的信息\ngoroutine ：显示或者切换当前的go\ngoroutines <span class=\"token builtin class-name\">:</span> 列出程序的所有go</code></pre></div>\n<h2>二、进入调试</h2>\n<h3>1、打断点</h3>\n<p>第一步先打断点，对于第一次才开始调试的人来说，最简单的就是打<code class=\"language-text\">main</code>函数的断点了.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> b main.main\nBreakpoint <span class=\"token number\">1</span> <span class=\"token builtin class-name\">set</span> at 0x1093038 <span class=\"token keyword\">for</span> main.main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./main.go:27\n<span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> bp\nBreakpoint <span class=\"token number\">1</span> at 0x1093038 <span class=\"token keyword\">for</span> main.main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./main.go:27 <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>2、运行到断点出</h3>\n<p><code class=\"language-text\">b</code>、<code class=\"language-text\">bp</code>是缩写，对应为打断点和打印所有的断点信息。打了断点之后就可以执行<code class=\"language-text\">c</code>这个命令了。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">continue</span>\n<span class=\"token operator\">></span> main.main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./main.go:27 <span class=\"token punctuation\">(</span>hits goroutine<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>:1 total:1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>PC: 0x1093038<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span><span class=\"token operator\">></span>  <span class=\"token number\">27</span>:\tfunc <span class=\"token function-name function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>3、打印堆栈信息</h3>\n<p>执行过后就会出现源代码，并且断点指向了<code class=\"language-text\">main</code>函数上,此时我们通过<code class=\"language-text\">stack</code>命令就可以看到这个<code class=\"language-text\">main</code>函数所在的<code class=\"language-text\">goroutine</code>栈了。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> stack\n<span class=\"token number\">0</span>  0x0000000001093038 <span class=\"token keyword\">in</span> main.main\n   at ./main.go:27\n<span class=\"token number\">1</span>  0x00000000010297ec <span class=\"token keyword\">in</span> runtime.main\n   at ./golang_work/go/src/runtime/proc.go:200\n<span class=\"token number\">2</span>  0x0000000001051011 <span class=\"token keyword\">in</span> runtime.goexit\n   at ./golang_work/go/src/runtime/asm_amd64.s:1337</code></pre></div>\n<p>如上就是显示了一个<code class=\"language-text\">goroutine</code>的堆栈，堆栈中的信息就保证了调用过程，所以我们就可以去分析<code class=\"language-text\">go</code>启动过程了。\n我们要从栈底往上看，所以我们首先去分析一下<code class=\"language-text\">asm_amd64.s</code>这个汇编代码。现在是逆向分析调用栈，后续的分析就是正向的过程。</p>\n<h2>三、分析启动过程</h2>\n<h3>1、分析asm_amd64.s这个文件</h3>\n<p>这里面的内容很多，我们不能全部看完，只能找一下重点，开始的两个函数都指向了<code class=\"language-text\">JMP\truntime·rt0_go(SB)</code>这条汇编代码，我们就去查看<code class=\"language-text\">rt0_go</code>这个函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">runtime<span class=\"token operator\">/</span>asm_amd64<span class=\"token punctuation\">.</span>s \nTEXT runtime·<span class=\"token function\">rt0_go</span><span class=\"token punctuation\">(</span>SB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>NOSPLIT<span class=\"token punctuation\">,</span>$<span class=\"token number\">0</span>\n\tCALL\truntime·<span class=\"token function\">args</span><span class=\"token punctuation\">(</span>SB<span class=\"token punctuation\">)</span>\n\tCALL\truntime·<span class=\"token function\">osinit</span><span class=\"token punctuation\">(</span>SB<span class=\"token punctuation\">)</span>\n\tCALL\truntime·<span class=\"token function\">schedinit</span><span class=\"token punctuation\">(</span>SB<span class=\"token punctuation\">)</span>\n\tCALL\truntime·<span class=\"token function\">newproc</span><span class=\"token punctuation\">(</span>SB<span class=\"token punctuation\">)</span>\n\tCALL\truntime·<span class=\"token function\">mstart</span><span class=\"token punctuation\">(</span>SB<span class=\"token punctuation\">)</span>\n\tCALL\truntime·<span class=\"token function\">abort</span><span class=\"token punctuation\">(</span>SB<span class=\"token punctuation\">)</span>\t<span class=\"token comment\">// mstart should </span></code></pre></div>\n<p>文件中的大部分内容都去掉了，我只留下了<code class=\"language-text\">CALL</code> 指令的部分，<code class=\"language-text\">call</code>调用的就是<code class=\"language-text\">runtime</code>包中的源代码，所以我们通过方法名就可以进行搜索了，并且是在可以运行之后的部分，所以上面就是<code class=\"language-text\">go</code>进程启动的过程。下面我们边打断点边查看每个函数都做了写什么内容。</p>\n<p>按顺序总结下runtime.rt0_go里几件重要的事：</p>\n<ul>\n<li>检查运行平台的CPU，设置好程序运行需要相关标志。</li>\n<li>TLS的初始化。</li>\n<li>runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。</li>\n<li>runtime.newproc创建新的goroutine用于绑定用户写的main方法。</li>\n<li>runtime.mstart开始goroutine的调度。</li>\n</ul>\n<h3>2、按顺序打上断点</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> b runtime.args\n<span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> b runtime.osinit\n<span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> b runtime.schedinit\n<span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> b runtime.newproc\n<span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> b runtime.mstart\n<span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> b runtime.abort\n\nBreakpoint <span class=\"token number\">2</span> at 0x10360ff <span class=\"token keyword\">for</span> runtime.args<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./go/src/runtime/runtime1.go:60 <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nBreakpoint <span class=\"token number\">3</span> at 0x102604f <span class=\"token keyword\">for</span> runtime.osinit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./go/src/runtime/os_darwin.go:79 <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nBreakpoint <span class=\"token number\">4</span> at 0x102a843 <span class=\"token keyword\">for</span> runtime.schedinit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./go/src/runtime/proc.go:526 <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nBreakpoint <span class=\"token number\">5</span> at 0x1030f90 <span class=\"token keyword\">for</span> runtime.newproc<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./go/src/runtime/proc.go:3239 <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nBreakpoint <span class=\"token number\">6</span> at 0x102c410 <span class=\"token keyword\">for</span> runtime.mstart<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./go/src/runtime/proc.go:1153 <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nBreakpoint <span class=\"token number\">7</span> at 0x10509a0 <span class=\"token keyword\">for</span> runtime.abort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ./go/src/runtime/asm_amd64.s:837 <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>3、runtime.args</h3>\n<p>打好断点之后，可以执行如下命令找到源码所在位置.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token punctuation\">(</span>dlv<span class=\"token punctuation\">)</span> s\n<span class=\"token operator\">></span> runtime.args<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n./go/src/runtime/runtime1.go:60 <span class=\"token punctuation\">(</span>hits total:1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>PC: 0x10360ff<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span><span class=\"token operator\">></span>  <span class=\"token number\">60</span>:\tfunc args<span class=\"token punctuation\">(</span>c int32, <span class=\"token function\">v</span> **byte<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>我们找到源码，并且验证了启动过程第一步就是这个</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">runtime<span class=\"token operator\">/</span>runtime1<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> <span class=\"token operator\">+</span><span class=\"token number\">60</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">args</span><span class=\"token punctuation\">(</span>c <span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> v <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\targc <span class=\"token operator\">=</span> c\n\targv <span class=\"token operator\">=</span> v\n\t<span class=\"token function\">sysargs</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nruntime<span class=\"token operator\">/</span>os_darwin<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> <span class=\"token operator\">+</span><span class=\"token number\">341</span>\n<span class=\"token comment\">//go:linkname executablePath os.executablePath</span>\n<span class=\"token keyword\">var</span> executablePath <span class=\"token builtin\">string</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">sysargs</span><span class=\"token punctuation\">(</span>argc <span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> argv <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// skip over argv, envv and the first string will be the path</span>\n\tn <span class=\"token operator\">:=</span> argc <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token function\">argv_index</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\tn<span class=\"token operator\">++</span>\n\t<span class=\"token punctuation\">}</span>\n\texecutablePath <span class=\"token operator\">=</span> <span class=\"token function\">gostringnocopy</span><span class=\"token punctuation\">(</span><span class=\"token function\">argv_index</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token comment\">// strip \"executable_path=\" prefix if available, it's added after OS X 10.11.</span>\n\t<span class=\"token keyword\">const</span> prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"executable_path=\"</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>executablePath<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> executablePath<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> prefix <span class=\"token punctuation\">{</span>\n\t\texecutablePath <span class=\"token operator\">=</span> executablePath<span class=\"token punctuation\">[</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个方法只做了一件事，就是把二进制文件的绝对路径找出来，并存在os.executablePath里。</p>\n<p>按照本文的测试工程：os.executablePath=$GOPATH/test/main</p>\n<h3>4、runtime.osinit</h3>\n<p>再接着运行就会到下一个断点，也就是<code class=\"language-text\">runtime.osinit()</code>这个函数。\n<code class=\"language-text\">osinit</code>这个函数是根据操作系统的不同来选择不同的执行函数的，我的是<code class=\"language-text\">mac</code>,所以执行的是<code class=\"language-text\">os_darwin.go</code>里面的函数，同时还有<code class=\"language-text\">os_linux.go</code>里面也有同样的函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">runtime<span class=\"token operator\">/</span>os_darwin<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> <span class=\"token operator\">+</span><span class=\"token number\">79</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">osinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tncpu <span class=\"token operator\">=</span> <span class=\"token function\">getncpu</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tphysPageSize <span class=\"token operator\">=</span> <span class=\"token function\">getPageSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个函数主要做来两件事：</p>\n<ul>\n<li>第一是获取当前电脑的<code class=\"language-text\">cpu</code>个数，并赋值给<code class=\"language-text\">runtime/runtime2.go</code>中的<code class=\"language-text\">ncpu</code>变量。</li>\n<li>第二是设置<code class=\"language-text\">runtime/malloc.go</code>中的<code class=\"language-text\">physPageSize</code>变量，这个变量是用于分配内存的，操作系统分配内存或者回收内存都是按这个数字的整数倍来操作的。我获取的是<code class=\"language-text\">4096</code>这个数字，所以是<code class=\"language-text\">4k</code>字节。</li>\n</ul>\n<h3>5、runtime.schedinit</h3>\n<p>再接着运行到下一个断点，就是<code class=\"language-text\">runtime.schedinit</code>这个函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">runtime<span class=\"token operator\">/</span>proc<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> <span class=\"token operator\">+</span><span class=\"token number\">526</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">schedinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//从TLS 中获取g</span>\n\t_g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\">// 是否开启竞争检测，启动方法go run -race main.go</span>\n\t<span class=\"token keyword\">if</span> raceenabled <span class=\"token punctuation\">{</span>\n\t\t_g_<span class=\"token punctuation\">.</span>racectx<span class=\"token punctuation\">,</span> raceprocctx0 <span class=\"token operator\">=</span> <span class=\"token function\">raceinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">//运行创建的最大线程数</span>\n\tsched<span class=\"token punctuation\">.</span>maxmcount <span class=\"token operator\">=</span> <span class=\"token number\">10000</span>\n\t<span class=\"token comment\">// 初始化一系列函数所在的PC计数器，用于traceback</span>\n\t<span class=\"token function\">tracebackinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\">//...</span>\n\t<span class=\"token function\">moduledataverify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\">//栈初始化,初始化了一个栈池，可以直接取，还有一个大栈的全局池.</span>\n\t<span class=\"token comment\">//golang 使用的是动态栈，初始是2k大小，后面增长，但是golang使用的不是分离栈，是连续栈，就是栈空间是连续的，分配的时候如果之前的空间不连续了，就拷贝一份到新的空间去。</span>\n\t<span class=\"token function\">stackinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">mallocinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">mcommoninit</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">cpuinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\">// must run before alginit</span>\n\t<span class=\"token function\">alginit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\">// maps must not be used before this call</span>\n\t<span class=\"token function\">modulesinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">// provides activeModules</span>\n\t<span class=\"token function\">typelinksinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// uses maps, activeModules</span>\n\t<span class=\"token function\">itabsinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>     <span class=\"token comment\">// uses activeModules</span>\n\n\t<span class=\"token function\">msigsave</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span>\n\tinitSigmask <span class=\"token operator\">=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>sigmask\n    <span class=\"token comment\">// 启动参数初始化</span>\n\t<span class=\"token function\">goargs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\">//</span>\n\t<span class=\"token function\">goenvs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\">// 解析debug变量，GODEBUG，GOTRACEBACK这些</span>\n\t<span class=\"token function\">parsedebugvars</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\">// gc 初始化</span>\n\t<span class=\"token function\">gcinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    \n\tsched<span class=\"token punctuation\">.</span>lastpoll <span class=\"token operator\">=</span> <span class=\"token function\">uint64</span><span class=\"token punctuation\">(</span><span class=\"token function\">nanotime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\tprocs <span class=\"token operator\">:=</span> ncpu\n\t<span class=\"token keyword\">if</span> n<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> <span class=\"token function\">atoi32</span><span class=\"token punctuation\">(</span><span class=\"token function\">gogetenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GOMAXPROCS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> ok <span class=\"token operator\">&amp;&amp;</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n\t\tprocs <span class=\"token operator\">=</span> n\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token function\">procresize</span><span class=\"token punctuation\">(</span>procs<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unknown runnable goroutine during bootstrap\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token comment\">// For cgocheck > 1, we turn on the write barrier at all times</span>\n\t<span class=\"token comment\">// and check all pointer writes. We can't do this until after</span>\n\t<span class=\"token comment\">// procresize because the write barrier needs a P.</span>\n\t<span class=\"token keyword\">if</span> debug<span class=\"token punctuation\">.</span>cgocheck <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token punctuation\">{</span>\n\t\twriteBarrier<span class=\"token punctuation\">.</span>cgo <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\t\twriteBarrier<span class=\"token punctuation\">.</span>enabled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> p <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> allp <span class=\"token punctuation\">{</span>\n\t\t\tp<span class=\"token punctuation\">.</span>wbBuf<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">if</span> buildVersion <span class=\"token operator\">==</span> <span class=\"token string\">\"\"</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// Condition should never trigger. This code just serves</span>\n\t\t<span class=\"token comment\">// to ensure runtime·buildVersion is kept in the resulting binary.</span>\n\t\tbuildVersion <span class=\"token operator\">=</span> <span class=\"token string\">\"unknown\"</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>mallocinit()：这个函数是内存分配器初始化。</p>\n</li>\n<li>\n<p>mcommoninit(mp *m):初始化m0这个线程</p>\n</li>\n<li>\n<p>cpuinit()：cpu初始化</p>\n</li>\n<li>\n<p>alginit()：初始化AES，HASH算法</p>\n</li>\n</ul>\n<h3>6、runtime.newproc()</h3>\n<p>再接着运行到下一个断点，就是<code class=\"language-text\">runtime.newproc</code>这个函数。</p>\n<ul>\n<li><a href=\"http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2goroutine%E7%9A%84%E5%88%9B%E5%BB%BA/\">http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2goroutine%E7%9A%84%E5%88%9B%E5%BB%BA/</a></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">runtime<span class=\"token operator\">/</span>proc<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> <span class=\"token operator\">+</span><span class=\"token number\">3239</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">newproc</span><span class=\"token punctuation\">(</span>siz <span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> fn <span class=\"token operator\">*</span>funcval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\targp <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> sys<span class=\"token punctuation\">.</span>PtrSize<span class=\"token punctuation\">)</span>\n\tgp <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tpc <span class=\"token operator\">:=</span> <span class=\"token function\">getcallerpc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">newproc1</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token builtin\">uint8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>argp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> siz<span class=\"token punctuation\">,</span> gp<span class=\"token punctuation\">,</span> pc<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>7、runtime.mstart()</h3>\n<p>再接着运行到下一个断点，就是<code class=\"language-text\">runtime.mstart</code>这个函数。\nmstart方法主要的执行路径是：</p>\n<p><strong>mstart -> mstart1 -> schedule -> execute</strong></p>\n<ul>\n<li>mstart做一些栈相关的检查，然后就调用mstart1。</li>\n<li>mstart1先做一些初始化与M相关的工作，例如是信号栈和信号处理函数的初始化。最后调用schedule。</li>\n<li>schedule逻辑是这四个方法里最复杂的。简单来说，就是要找出一个可运行的G，不管是从P本地的G队列、全局调度器的G队列、GC - worker、因IO阻塞的G、甚至从别的P里偷。然后传给execute运行。</li>\n<li>execute对传进来的G设置好相关的状态后，就加载G自身记录着的PC、SP等寄存器信息，恢复现场继续执行。</li>\n</ul>\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://github.com/go-delve/delve\">dlv 官网</a></li>\n<li><a href=\"http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/\">http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</a></li>\n<li><a href=\"http://blog.jobbole.com/93100/\">http://blog.jobbole.com/93100/</a></li>\n</ul>","frontmatter":{"title":"Go Bootstrap Process","date":"June 10, 2019","description":null}},"previous":{"fields":{"slug":"/2019-06-08-Linux-Tcp-端口耗尽/"},"frontmatter":{"title":"Linux Tcp 端口耗尽"}},"next":{"fields":{"slug":"/2019-06-14-Go并发编程测试分解/"},"frontmatter":{"title":"Go 并发编程测试分析"}}},"pageContext":{"id":"53f9e5f2-e9fb-5a8b-87f7-7b3956772160","previousPostId":"c89f5c10-b95b-5d23-93aa-58986a87c16a","nextPostId":"41a8b1d8-aef8-5946-9e63-9e6c62db69c6"}},
    "staticQueryHashes": ["2841359383","3257411868"]}