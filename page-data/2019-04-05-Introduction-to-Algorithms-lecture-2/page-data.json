{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2019-04-05-Introduction-to-Algorithms-lecture-2/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"8315a56a-18c9-522c-a819-084676058a0c","excerpt":"这节课的主要知识就是讲诉了使用三种方法去求解递归式。 渐进记号 渐进记号主要有三种，具体定义参考课本。把渐进记号用来描述算法的运行时间。 Θ 记号(上界) 使得存在正数常量,使得对所有 ,有 Ω 记号（下界）  使得存在正数常量和,使得对所有有 . O…","html":"<p>这节课的主要知识就是讲诉了使用三种方法去求解递归式。</p>\n<h1>渐进记号</h1>\n<p>渐进记号主要有三种，具体定义参考课本。把渐进记号用来描述算法的运行时间。</p>\n<h2>Θ 记号(上界)</h2>\n<p><code class=\"language-text\">f(n) = Θ(g(n))</code>使得存在正数常量<code class=\"language-text\">c1、c2、n0</code>,使得对所有 <code class=\"language-text\">n≥n0</code>,有<code class=\"language-text\">0≤c1g(n) ≤ f(n)≤ c2g(n)</code></p>\n<h2>Ω 记号（下界）</h2>\n<p><code class=\"language-text\">f(n)=Ω(g(n))</code> 使得存在正数常量<code class=\"language-text\">c</code>和<code class=\"language-text\">n0</code>,使得对所有<code class=\"language-text\">n≥n0</code>有 <code class=\"language-text\">0 ≤ cg(n) ≤ f(n)</code>.</p>\n<h2>O 记号</h2>\n<p><code class=\"language-text\">Θ</code>记号渐进的给出一个函数的上界和下界，当只有一个渐进上界时，使用<code class=\"language-text\">O</code>记号。\n<code class=\"language-text\">f(n) = O(g(n)) </code> 使得存在正数常量<code class=\"language-text\">c,n0</code>，使得对所有<code class=\"language-text\">n≥n0</code>,有<code class=\"language-text\">0≤f(n)≤cg(n)</code></p>\n<h1>求解递归式</h1>\n<p>使用递归式来刻画分治算法的运行时间，如下三种方法便是学习如何求解递归式。\n递归式如下：\n<img src=\"1557153490587.jpg\" alt=\"递归式\"></p>\n<h2>替换法求解递归式</h2>\n<p>代入法求解递归式分两步：\n1、猜测解的形式。需要靠经验，或者借助递归树来得出好的猜测。\n2、归纳验证，求解常量。</p>\n<h2>递归树求解递归式</h2>\n<p>此方法参考课本内容。</p>\n<h2>主方法求解递归式</h2>\n<p>主方法定义了一个通用的递归式求解方法，如下</p>\n<p><code class=\"language-text\">T(n) = aT(n/b) + f(n)</code></p>\n<p>含义：它将规模为<code class=\"language-text\">n</code>的问题分解为<code class=\"language-text\">a</code>个子问题，每个子问题规模为<code class=\"language-text\">n/b</code>，其中<code class=\"language-text\">a</code>和<code class=\"language-text\">b</code>都是正常数，<code class=\"language-text\">a</code>个子问题递归地进行求解，每个话费时间<code class=\"language-text\">T(n/b)</code>。函数<code class=\"language-text\">fn</code>包含了问题分解和子问题解合并的代价。</p>\n<p>主方法依赖下面的定理：令<code class=\"language-text\">a>= 1</code>和<code class=\"language-text\">b>1</code>是常数，<code class=\"language-text\">fn</code>是一个函数，<code class=\"language-text\">Tn</code>是定义在非负整数上的递归式：\n<code class=\"language-text\">T(n) = aT(n/b) + f(n)</code>\n<code class=\"language-text\">Tn</code>有如下渐进界：</p>\n<ul>\n<li>1、若对某个常数<code class=\"language-text\">ε>0</code>有<code class=\"language-text\">f(n)=O(nlogba–ε)</code>则<code class=\"language-text\"> T(n) = Θ(nlogba) .</code></li>\n<li>2、若<code class=\"language-text\">f(n) = Θ(nlogba)</code>则<code class=\"language-text\">T(n) = Θ(nlogba lgk+1n) .</code></li>\n<li>3、若某个常数<code class=\"language-text\">ε>0</code>有<code class=\"language-text\">f(n)=Ω(nlogba+ε)</code>且对某个常数<code class=\"language-text\">c&lt;1</code>和所有足够大的<code class=\"language-text\">n</code>有<code class=\"language-text\">af(n/b) &lt; cf(n) </code>,则<code class=\"language-text\">T(n) = Θ( f (n) ) </code></li>\n</ul>\n<p>递归树的高度：<code class=\"language-text\">h = logbn</code>\n叶子结点个数：<code class=\"language-text\">l =  nlogba</code></p>","frontmatter":{"title":"渐进符号、替换、递归树、主方法","date":"April 05, 2019","description":null}},"previous":{"fields":{"slug":"/2019-03-30-Introduction-to-Algorithms-lecture-1/"},"frontmatter":{"title":"算法分析、插入排序、归并排序"}},"next":{"fields":{"slug":"/2019-05-07-file-save/"},"frontmatter":{"title":"文件存储系统设计"}}},"pageContext":{"id":"8315a56a-18c9-522c-a819-084676058a0c","previousPostId":"bf5dcc7b-394c-51b4-a6d3-d23a60a08141","nextPostId":"5d47ad55-9e3c-58b3-a4db-40d5e5b9c664"}},
    "staticQueryHashes": ["2841359383","3257411868"]}