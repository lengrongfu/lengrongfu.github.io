{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2019-03-30-Introduction-to-Algorithms-lecture-1/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"bf5dcc7b-394c-51b4-a6d3-d23a60a08141","excerpt":"…","html":"<blockquote>\n<p>本系列文章是我学习算法概论(第三版)这本书的一些笔记和感悟，我没有纯看书，而是结合了<code class=\"language-text\">MIT</code>的公开课，把书籍作为课本，查看具体细节，主要是看课程，每节课时长<code class=\"language-text\">60</code>分钟左右，视频在网易公开课上有中文字母。次课程会从数学的角度去分析运行时，课程总共有<code class=\"language-text\">21</code>，前<code class=\"language-text\">6</code>课讲解都是排序算法，对应课本上的前三章，这部分不涉及到数据结构,后面的章节都涉及数据结构以及应用。</p>\n</blockquote>\n<h1>算法分析</h1>\n<h2>为什么学习算法和性能</h2>\n<ul>\n<li>算法帮助我们去理解可扩展性。</li>\n<li>性能常常用来划分什么是可行的什么是不可行的。</li>\n<li>算法数学提供了一个讨论程序特性的语言。(用数学来刻画程序的特性，比如运行时)。</li>\n<li>性能是计算机的共性。</li>\n<li>程序性能和计算机资源是无关的。比如一台很老的电脑和一台现代的电脑相比，不能说现代电脑就一定比旧电脑运行的快，如果旧电脑运行的算法比较高效的话，一定会在某一时刻运行时间会小于新电脑。</li>\n</ul>\n<h1>排序问题</h1>\n<p><strong>Input:</strong> 一个序列 <code class=\"language-text\">&lt;a1,a2,a3,.....,an></code>\n<strong>Output:</strong> 输出一个排序后的序列<code class=\"language-text\">&lt;a1',a2',a3',......,an'></code>, 使得 <code class=\"language-text\">a1' &lt; a2' &lt; a3' &lt; .... &lt; an'</code></p>\n<h2>插入排序</h2>\n<h2>伪代码</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">Insertion<span class=\"token operator\">-</span><span class=\"token function\">SORT</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> j ← <span class=\"token number\">2</span> to n\n        <span class=\"token keyword\">do</span> key←A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n            i←j–<span class=\"token number\">1</span>\n            <span class=\"token keyword\">while</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span> and A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> key\n                <span class=\"token keyword\">do</span> A<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> ← A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> \n                i←i–<span class=\"token number\">1</span>\n        A<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">InsertionSort</span><span class=\"token punctuation\">(</span>A <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">for</span> i<span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span>  <span class=\"token punctuation\">{</span>\n\t\tkey <span class=\"token operator\">:=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\t\tj <span class=\"token operator\">:=</span> i<span class=\"token operator\">-</span><span class=\"token number\">1</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> key <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">{</span>\n\t\t\tA<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n\t\t\tj <span class=\"token operator\">=</span> j<span class=\"token operator\">-</span><span class=\"token number\">1</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\tA<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>运行时分析</h3>\n<ul>\n<li>运行时依赖输入，如果输入是排好序的，那是很容易排序的。</li>\n<li>输入元素的个数，短序列比长序列更好排序。</li>\n<li>通常来说，我们分析的是运行时的上限。</li>\n</ul>\n<p>分析的方式</p>\n<ul>\n<li>最差情况(通常用次分析)</li>\n</ul>\n<p>T(n) = 算法的最长运行时在任何的输入下。</p>\n<ul>\n<li>平均情况</li>\n</ul>\n<p>T(n) = 算法的预期时间在总体输入下。</p>\n<ul>\n<li>最好情况</li>\n</ul>\n<p>T(n) = 在某些输入下运行时间比较好。</p>\n<h3>插入排序分析</h3>\n<p>$$\nT(n)=\\sum_{j=2}^{n} \\Theta(j)=\\Theta\\left(n^{2}\\right)\n$$</p>\n<p>我们分析最差情况，如果输入是逆序的，那么执行的次数就是<code class=\"language-text\">n+(n-1)+(n-2)+...+1=n(n-1)/2</code> 就是一个等差数列求和，就得到如上的公式，</p>\n<p>$$\nT(n)=\\Theta\\left(n^{2}/2\\right) + \\Theta\\left(n-1\\right)\n$$</p>\n<p>忽略低阶项和高价项的常数，就得到如下运行时间，所以插入排序是和输入大小成平方比。</p>\n<p>$$\nT(n) = \\Theta\\left(n^{2}\\right)\n$$</p>\n<h2>归并排序</h2>\n<h3>伪代码</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token expression\">MERGE<span class=\"token operator\">-</span><span class=\"token function\">SORT</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span></span></span>\n    <span class=\"token number\">1.</span> Ifn<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>done<span class=\"token punctuation\">.</span>\n    <span class=\"token number\">2.</span> 递归排序 A<span class=\"token punctuation\">[</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">.</span> <span class=\"token punctuation\">.</span> ⎡n<span class=\"token operator\">/</span><span class=\"token number\">2</span>⎤ <span class=\"token punctuation\">]</span> and A<span class=\"token punctuation\">[</span> ⎡n<span class=\"token operator\">/</span><span class=\"token number\">2</span>⎤<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token punctuation\">.</span> <span class=\"token punctuation\">.</span> n <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span> # ⎡n<span class=\"token operator\">/</span><span class=\"token number\">2</span>⎤ 向下取整\n    <span class=\"token number\">3.</span> 合并这两个`list`</code></pre></div>\n<h3>归并排序分析</h3>\n<p><img src=\"1557153490587.jpg\" alt=\"公式\"></p>\n<p>这个公式在后面会用主方法来进行分析运行的上界。</p>\n<p><img src=\"2.png\" alt=\"2\"></p>\n<p>递归树的高度是<code class=\"language-text\">lgn</code>，每一个层级运行时为<code class=\"language-text\">cn</code>，所以<code class=\"language-text\">Tn = O(cn*lgn)</code>,就是高度乘以每一层的时间，前面的<code class=\"language-text\">c</code>为常量，可以忽略。</p>\n<h2>结论</h2>\n<ul>\n<li><code class=\"language-text\">Θ(nlgn)</code>比<code class=\"language-text\">Θ(n2)</code>慢的多。</li>\n<li>归并排序在最坏情况下比插入排序好的多。</li>\n<li>实践中，当<code class=\"language-text\">n > 30</code> 时，归并排序就比插入排序好的多。</li>\n</ul>","frontmatter":{"title":"算法分析、插入排序、归并排序","date":"March 30, 2019","description":null}},"previous":{"fields":{"slug":"/2019-03-25-Inverted-index/"},"frontmatter":{"title":"Inverted-index"}},"next":{"fields":{"slug":"/2019-04-05-Introduction-to-Algorithms-lecture-2/"},"frontmatter":{"title":"渐进符号、替换、递归树、主方法"}}},"pageContext":{"id":"bf5dcc7b-394c-51b4-a6d3-d23a60a08141","previousPostId":"e54ec16f-0044-55cc-a261-8213f3df3076","nextPostId":"8315a56a-18c9-522c-a819-084676058a0c"}},
    "staticQueryHashes": ["2841359383","3257411868"]}