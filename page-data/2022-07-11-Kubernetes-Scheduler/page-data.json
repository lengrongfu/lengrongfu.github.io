{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2022-07-11-Kubernetes-Scheduler/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"019a283d-f02c-5e7c-a1b9-ca15a4684af6","excerpt":"Kubernetes Scheduler Scheduler Workflow  定义了和，在中有串行和两个阶段，是异步并行阶段。 Scheduler FrameWork…","html":"<h1>Kubernetes Scheduler</h1>\n<h2>Scheduler Workflow</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/137ee9eb9c987670962a8910825aab00/2f2ab/schedule-workflow.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.53164556962025%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAUBBP/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAG04KVGiX//xAAZEAEAAgMAAAAAAAAAAAAAAAABABEQITH/2gAIAQEAAQUCtmyHGUOP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/AUyf/8QAGRAAAgMBAAAAAAAAAAAAAAAAEKEAATEy/9oACAEBAAY/AuXMYs//xAAcEAEAAgMAAwAAAAAAAAAAAAABABEhMUFRYeH/2gAIAQEAAT8hVE+ku7nkJQpT4m+T3vuVMkCtT//aAAwDAQACAAMAAAAQY8//xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQMBAT8QHZ//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxAI/8QAHRAAAgICAwEAAAAAAAAAAAAAAREAMSFRQWFxgf/aAAgBAQABPxDPCWgFwgXuQDIheuo4HWzX2D7nNpCAzY2YAVS7c//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"schedule-workflow\"\n        title=\"schedule-workflow\"\n        src=\"/static/137ee9eb9c987670962a8910825aab00/828fb/schedule-workflow.jpg\"\n        srcset=\"/static/137ee9eb9c987670962a8910825aab00/ff44c/schedule-workflow.jpg 158w,\n/static/137ee9eb9c987670962a8910825aab00/a6688/schedule-workflow.jpg 315w,\n/static/137ee9eb9c987670962a8910825aab00/828fb/schedule-workflow.jpg 630w,\n/static/137ee9eb9c987670962a8910825aab00/0ede0/schedule-workflow.jpg 945w,\n/static/137ee9eb9c987670962a8910825aab00/3ac88/schedule-workflow.jpg 1260w,\n/static/137ee9eb9c987670962a8910825aab00/2f2ab/schedule-workflow.jpg 1643w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><code class=\"language-text\">Scheduler WorkFlow</code>定义了<code class=\"language-text\">Scheduler Cycle</code>和<code class=\"language-text\">Binding Cycle</code>，在<code class=\"language-text\">Scheduler Cycle</code>中有串行<code class=\"language-text\">Filter </code>和<code class=\"language-text\">Score</code>两个阶段，<code class=\"language-text\">Bind</code>是异步并行阶段。</p>\n<h2>Scheduler FrameWork</h2>\n<p><code class=\"language-text\">Scheduler FrameWork</code>是通过在<code class=\"language-text\">Scheduler  Cycle</code>中通过预留扩展点来进行扩展调度流程，<code class=\"language-text\">FrameWork</code>预留了多个扩展点:</p>\n<ul>\n<li><code class=\"language-text\">QueueSortFunc() LessFunc</code>： <code class=\"language-text\">Pod</code> 从队列中获取的优先级</li>\n<li><code class=\"language-text\">PreFilter</code>： 在过滤之前执行</li>\n<li><code class=\"language-text\">Filter</code>： 执行过滤函数</li>\n<li><code class=\"language-text\">PostFilter</code>: 执行抢占</li>\n<li><code class=\"language-text\">PreScore</code>：执行`Score之前执行</li>\n<li><code class=\"language-text\">Score</code>: 执行<code class=\"language-text\">Node</code>打分</li>\n<li><code class=\"language-text\">PreBind</code>: 执行<code class=\"language-text\">Binding</code>之前</li>\n<li><code class=\"language-text\">Bind</code>： 执行<code class=\"language-text\">Binding</code>动作</li>\n<li><code class=\"language-text\">PostBind</code>：执行<code class=\"language-text\">Binding</code>之后</li>\n</ul>\n<p>自定义<code class=\"language-text\">Schedlue</code>可以通过直接实现<code class=\"language-text\">Scheduler FrameWork</code>中暴露的接口，然后在启动过程中进行<code class=\"language-text\">Plugin</code>注册即可。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\trand<span class=\"token punctuation\">.</span><span class=\"token function\">Seed</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">UTC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">UnixNano</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\tlogs<span class=\"token punctuation\">.</span><span class=\"token function\">InitLogs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">defer</span> logs<span class=\"token punctuation\">.</span><span class=\"token function\">FlushLogs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\tcmd <span class=\"token operator\">:=</span> app<span class=\"token punctuation\">.</span><span class=\"token function\">NewSchedulerCommand</span><span class=\"token punctuation\">(</span>\n\t\tapp<span class=\"token punctuation\">.</span><span class=\"token function\">WithPlugin</span><span class=\"token punctuation\">(</span>sample<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">,</span> sample<span class=\"token punctuation\">.</span>New<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">:=</span> cmd<span class=\"token punctuation\">.</span><span class=\"token function\">Execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Fprintf</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span>Stderr<span class=\"token punctuation\">,</span> <span class=\"token string\">\"%v\\n\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n\t\tos<span class=\"token punctuation\">.</span><span class=\"token function\">Exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Scheduler Plugin</h2>\n<p>如下的<code class=\"language-text\">Scheduler Plugin</code>是<code class=\"language-text\">kube-scheduler</code>里面内嵌的插件，涵盖了<code class=\"language-text\">WorkFlow</code>里面的所有流程。</p>\n<h3>Sort(排序)</h3>\n<h4>1.PrioritySort</h4>\n<p><code class=\"language-text\">PrioritySort</code>优先队列是进行<code class=\"language-text\">Pod</code>在入队时的排序函数，按找<code class=\"language-text\">Pod</code>的优先级进行排序，通过读取<code class=\"language-text\">pod.Spec.Priority</code>字段值进行排序，如果未设置<code class=\"language-text\">Pod</code>的优先级则按照添加到队列的时间先后进行排序。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">p1 <span class=\"token operator\">:=</span> pod1<span class=\"token punctuation\">.</span>Spec<span class=\"token punctuation\">.</span>Priority <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> ? <span class=\"token operator\">*</span>pod1<span class=\"token punctuation\">.</span>Spec<span class=\"token punctuation\">.</span>Priority <span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\np2 <span class=\"token operator\">:=</span> pod2<span class=\"token punctuation\">.</span>Spec<span class=\"token punctuation\">.</span>Priority <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> ? <span class=\"token operator\">*</span>pod2<span class=\"token punctuation\">.</span>Spec<span class=\"token punctuation\">.</span>Priority <span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>p1 <span class=\"token operator\">></span> p2<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>p1 <span class=\"token operator\">==</span> p2 <span class=\"token operator\">&amp;&amp;</span> pInfo1<span class=\"token punctuation\">.</span>Timestamp<span class=\"token punctuation\">.</span><span class=\"token function\">Before</span><span class=\"token punctuation\">(</span>pInfo2<span class=\"token punctuation\">.</span>Timestamp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Filter(预选)</h3>\n<h4>1. InterPodAffinity</h4>\n<p><code class=\"language-text\">InterPodAffinity</code> 检查<code class=\"language-text\">Pod</code>的亲和性是否满足，实现了<code class=\"language-text\">PreFilterPlugin</code>和<code class=\"language-text\">FilterPlugin</code>两个插件；</p>\n<h4>2. NodeAffinity</h4>\n<p><code class=\"language-text\">NodeAffinity</code>是<code class=\"language-text\">Node</code>亲和性的过滤，通过<code class=\"language-text\">pod.Spec.Affinity.NodeAffinity </code>是否配置<code class=\"language-text\">Node</code>亲和性和<code class=\"language-text\">Node</code>进行<code class=\"language-text\">Match</code>动作。</p>\n<h4>3.NodeName</h4>\n<p><code class=\"language-text\">NodeName</code>用于在对<code class=\"language-text\">pod.Spec.NodeName</code>字段值的判断，判断是否是当前的<code class=\"language-text\">Node</code>，如果指定了<code class=\"language-text\">pod.Spec.NodeName</code>并且不是当前的节点，则返回<code class=\"language-text\">UnschedulableAndUnresolvable</code>状态。</p>\n<h4>4.NodePorts</h4>\n<p><code class=\"language-text\">NodePorts</code>用于检查要启用的端口是否已经在<code class=\"language-text\">Node</code>上使用过，如果使用过则返回<code class=\"language-text\">Unschedulable</code>状态。</p>\n<h4>5.NodeResourcesFit</h4>\n<p><code class=\"language-text\">NodeResourcesFit</code> 检查节点是否有足够的资源，如:<code class=\"language-text\">cpu</code>、<code class=\"language-text\">memory</code>、<code class=\"language-text\">gpu</code>等，通过那取<code class=\"language-text\">max_resource(sum_pod, any_init_container)</code>和<code class=\"language-text\">node</code>可分配的资源来判断节点是否资源足够。如果有任一资源不够，此节点则会返回资源不足被过滤。</p>\n<h4>6.NodeUnschedulable</h4>\n<p><code class=\"language-text\">NodeUnschedulable</code> 插件过滤设置<code class=\"language-text\">node.Spec.Unschedulable=true</code>的节点，但是如果<code class=\"language-text\">Pod</code>设置了容忍<code class=\"language-text\">Unschedulable</code>的污点则不过滤。</p>\n<h4>7.NodeVolumeLimits</h4>\n<p><code class=\"language-text\">NodeVolumeLimits</code>是一个节点检查<code class=\"language-text\">volume</code>容量的插件； 校验PVC指定的Provision在CSI plugin或非CSI Plugin（后三个）上报的单机最大挂盘数（存储插件提供方一般对每个节点的单机最大挂载磁盘数是有限制的）</p>\n<h4>8.PodTopologySpread</h4>\n<p><code class=\"language-text\">PodTopologySpread</code> 是用于检查<code class=\"language-text\">Pod</code>的拓扑逻辑是否满足条件，</p>\n<h4>9.TaintToleration</h4>\n<p><code class=\"language-text\">TaintToleration</code>是一个污点容忍度的插件，用于检查<code class=\"language-text\">Pod</code>是否能容忍次污点。<code class=\"language-text\">Taint</code>污点是<code class=\"language-text\">Node</code>上的标签，<code class=\"language-text\">Toleration</code>容忍度是<code class=\"language-text\">Pod</code>上的功能，一个容忍度和一个污点相“匹配”是指它们有一样的<code class=\"language-text\">key</code>和<code class=\"language-text\">value</code>。</p>\n<h4>10.VolumeBinding</h4>\n<p><code class=\"language-text\">VolumeBinding</code>检查<code class=\"language-text\">Pod</code>挂载的<code class=\"language-text\">PVC</code>，如果其对应<code class=\"language-text\">SC(StorageClass)</code>的<code class=\"language-text\">VolumeBindingMode</code>是<code class=\"language-text\">Immediate</code>模式，该<code class=\"language-text\">PVC</code>必须已经是<code class=\"language-text\">bound</code>，否则需要返回<code class=\"language-text\">UnschedulableAndUnresolvable</code>。</p>\n<h4>11.VolumeRestrictions</h4>\n<p><code class=\"language-text\">VolumeRestrictions</code> 检查挂载该Node上的卷是否满足存储提供者的要求</p>\n<h3>Score(优选)</h3>\n<h4>1.ImageLocality</h4>\n<p><code class=\"language-text\">ImageLocality</code>是一个打分插件，对于调度<code class=\"language-text\">Pod</code>的镜像已经存在<code class=\"language-text\">Node</code>上给评分。已经存在的镜像并且镜像越大的分越高；（逻辑就是越大的镜像如果被重新拉取需要花费更多的时间，但是小的镜像拉起来就快，所以镜像存在并且越大的分越高就是这个逻辑）;如果一个节点上的镜像总大小<code class=\"language-text\">&lt; 23Mb</code>则<code class=\"language-text\">node</code>会被打<code class=\"language-text\">0</code>分；如果一个节点上的镜像总大于<code class=\"language-text\">1G * 容器数</code>则会被打<code class=\"language-text\">1</code>分。</p>\n<h4>2.InterPodAffinity</h4>\n<p><code class=\"language-text\">InterPodAffinity</code>在<code class=\"language-text\">Pod</code>亲和性之间计算亲和性的的分值。</p>\n<h4>3.NodeAffinity</h4>\n<p><code class=\"language-text\">NodeAffinity</code>是通过节点的亲和性来进行节点打分的，<code class=\"language-text\">PreScore</code> 主要逻辑是从<code class=\"language-text\">pod.Spec.Affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution</code>字段中获取首选节点亲和配置，主要的是配置的<code class=\"language-text\">weight</code>字段值，在通过<code class=\"language-text\">Label</code>匹配过程中，发现<code class=\"language-text\">Node.Meta.Label</code>是匹配<code class=\"language-text\">matchExpressions</code>中的字段则<code class=\"language-text\">score += weight</code>，这样这个节点的优先级就提高了。</p>\n<h4>4.NodeResourcesBalancedAllocation</h4>\n<p><code class=\"language-text\">NodeResourcesBalancedAllocation</code>节点资源均衡插件，是一个通过<code class=\"language-text\">cpu</code>和<code class=\"language-text\">memory</code>容量分数之间的差异，根据他们的优先级进行排名；对于资源使用率均衡的节点分值更高。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># ResourceSpec[{\"name\":\"cpu\",\"Weight\":1},{\"name\":\"memory\",\"Weight\":1}]\n\nstd =  Σ((fraction(i)-mean)^2)/len(resources)\n# std计算取决于需要均衡几种资源，如果只有cpu和memory\nstd=Abs( (cpuRequest1/cpuAllocable1 - memoryRequest1/memoryAllocable1) / 2 )\n# node打分则由如下计算\nscore = (1 - std) * MaxNodeScore(100)</code></pre></div>\n<h4>5.NodeResourcesFit</h4>\n<p><code class=\"language-text\">NodeResourcesFit</code>打分已经配置的策略进行，有如下三种：</p>\n<ul>\n<li><code class=\"language-text\">LeastAllocated</code>: 优先分配资源最少的节点；就是资源堆叠</li>\n<li><code class=\"language-text\">MostAllocated</code>: 优先分配资源最多的节点；就是资源打散</li>\n<li><code class=\"language-text\">RequestedToCapacityRatio</code>: 可以自定义函数，对资源容量进行打分。</li>\n</ul>\n<p><code class=\"language-text\">LeastAllocated</code>计算节点分值逻辑：<code class=\"language-text\">(cpu((capacity-requested)*MaxNodeScore*cpuWeight/capacity) + memory((capacity-requested)*MaxNodeScore*memoryWeight/capacity) + ...)/weightSum</code></p>\n<p>MostAllocated 计算节点分值逻辑：<code class=\"language-text\">(cpu(MaxNodeScore * sum(requested) / capacity) + memory(MaxNodeScore * sum(requested) / capacity) + ...) / weightSum</code></p>\n<p><code class=\"language-text\">capacity</code>是<code class=\"language-text\">allocable</code></p>\n<h4>6.PodTopologySpread</h4>\n<p><code class=\"language-text\">PodTopologySpread</code>权重为2</p>\n<h4>7.SelectorSpread</h4>\n<p><code class=\"language-text\">SelectorSpread</code>是一个计算选择器传播优先级的打分插件；</p>\n<h4>8.TaintToleration</h4>\n<p><code class=\"language-text\">TaintToleration计算无法容忍污点的一个插件，用于给</code>Pod 无法容忍污点打分，每一个无法容忍则<code class=\"language-text\">+1</code>，最后得到的就是<code class=\"language-text\">Node</code>的分。</p>\n<h3>Binding(绑定)</h3>\n<h4>1. DefaultBind</h4>\n<p><code class=\"language-text\">DefaultBind</code>是通过使用<code class=\"language-text\">k8s client</code>绑定<code class=\"language-text\">Pod</code>到<code class=\"language-text\">Node</code>。绑定流程是先创建一个<code class=\"language-text\">Binding</code>类型对象，通过设置<code class=\"language-text\">Target</code>字段值，来记录绑定对象的目标对象。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"># Binding是将一个对象与另一个对象联系起来\n<span class=\"token keyword\">type</span> Binding <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\tmetav1<span class=\"token punctuation\">.</span>TypeMeta <span class=\"token string\">`json:\",inline\"`</span>\n\tmetav1<span class=\"token punctuation\">.</span>ObjectMeta <span class=\"token string\">`json:\"metadata,omitempty\" protobuf:\"bytes,1,opt,name=metadata\"`</span>\n\tTarget ObjectReference <span class=\"token string\">`json:\"target\" protobuf:\"bytes,2,opt,name=target\"`</span>\n<span class=\"token punctuation\">}</span>\nbinding <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>v1<span class=\"token punctuation\">.</span>Binding<span class=\"token punctuation\">{</span>\n\t\tObjectMeta<span class=\"token punctuation\">:</span> metav1<span class=\"token punctuation\">.</span>ObjectMeta<span class=\"token punctuation\">{</span>Namespace<span class=\"token punctuation\">:</span> p<span class=\"token punctuation\">.</span>Namespace<span class=\"token punctuation\">,</span> Name<span class=\"token punctuation\">:</span> p<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">,</span> UID<span class=\"token punctuation\">:</span> p<span class=\"token punctuation\">.</span>UID<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\tTarget<span class=\"token punctuation\">:</span>     v1<span class=\"token punctuation\">.</span>ObjectReference<span class=\"token punctuation\">{</span>Kind<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Node\"</span><span class=\"token punctuation\">,</span> Name<span class=\"token punctuation\">:</span> nodeName<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>创建<code class=\"language-text\">Binding</code>对象之后，通过<code class=\"language-text\">Pods</code>的<code class=\"language-text\">Bind</code>方法就可以进行结果绑定。最终是创建<code class=\"language-text\">Pod</code>的绑定。</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\">POST /api/v1/namespaces/{namespace}/pods/{name}/binding\n<span class=\"token header-name keyword\">namespace:</span> pod namespace\n<span class=\"token header-name keyword\">name:</span> binding 名字\n<span class=\"token header-name keyword\">body:</span> Binding对象结构体</code></pre></div>\n<p>选中的节点在和待调度Pod进行Bind的时候，有可能会Bind失败，此时需要做回退，把Pod的Assumed状态退回Initial，从Node里面把Pod数据账本擦除掉，会把Pod重新丢回到unschedulableQ队列里面。在unschedulableQ里，如果一个Pod一分钟没调度过，就会重新回到activeQ。它的轮询周期是30s。</p>\n<p>调度失败的<code class=\"language-text\">Pod</code>会放到<code class=\"language-text\">backoffQ</code>，在<code class=\"language-text\">backoffQ</code>里等待的时间会比在<code class=\"language-text\">unschedulableQ</code>里更短，<code class=\"language-text\">backoffQ</code>里的降级策略是<code class=\"language-text\">2</code>的指数次幂降级。假设重试第一次为<code class=\"language-text\">1s</code>，那第二次就是<code class=\"language-text\">2s</code>，第三次就是<code class=\"language-text\">4s</code>，但最大到<code class=\"language-text\">10s</code>。</p>\n<h4>2.VolumeBinding</h4>\n<p><code class=\"language-text\">VolumeBinding</code>是<code class=\"language-text\">PreBinding</code>作为<code class=\"language-text\">Binding</code>之前检查的<code class=\"language-text\">Volume</code>是否绑定到<code class=\"language-text\">Node</code>上面，</p>\n<h3>Preemption(抢占)</h3>\n<h4>1.DefaultPreemption</h4>\n<p><code class=\"language-text\">DefaultPreemption</code>是一个<code class=\"language-text\">PostFilter</code>插件，实现了默认抢占逻辑；当高优先级的<code class=\"language-text\">Pod</code>没有找到合适的<code class=\"language-text\">Node</code>时，会执行<code class=\"language-text\">Preempt</code>抢占算法，抢占的流程。</p>\n<ul>\n<li>一个<code class=\"language-text\">Pod</code>进入抢占的时候，首先会判断<code class=\"language-text\">Pod</code>是否拥有抢占的资格，有可能上次已经抢占过一次。</li>\n<li>如果符合抢占资格，会先对所有的节点进行一次过滤，过滤出符合这次抢占要求的节点。然后</li>\n<li>模拟一次调度，把优先级低的<code class=\"language-text\">Pod</code>先移除出去，再尝试能否把待抢占的<code class=\"language-text\">Pod</code>放置到此节点上。然后通过这个过程从过滤剩下的节点中选出一批节点进行抢占。</li>\n<li><code class=\"language-text\">ProcessPreemptionWithExtenders</code>是一个扩展的钩子，用户可以在这里加一些自己抢占节点的策略。如果没有扩展的钩子，这里面不做任何动作。</li>\n<li><code class=\"language-text\">PickOneNodeForPreemption</code>，从上面选出的节点里挑选出最合适的一个节点，策略包括：\n<ul>\n<li>优先选择打破<code class=\"language-text\">PDB</code>最少的节点；</li>\n<li>其次选择待抢占<code class=\"language-text\">Pods</code>中最大优先级最小的节点；</li>\n<li>再次选择待抢占<code class=\"language-text\">Pods</code>优先级加和最小的节点；</li>\n<li>接下来选择待抢占<code class=\"language-text\">Pods</code>数目最小的节点；</li>\n<li>最后选择拥有最晚启动<code class=\"language-text\">Pod</code>的节点；</li>\n</ul>\n</li>\n</ul>\n<p>通过过滤之后，会选出一个最合适的节点。对这个节点上待抢占的<code class=\"language-text\">Pod</code>进行<code class=\"language-text\">delete</code>，完成抢占过程。</p>","frontmatter":{"title":"Kubernetes Scheduler","date":"July 11, 2022","description":"Kubernetes Scheduler 深入浅出"}},"previous":{"fields":{"slug":"/2022-05-20-CRUSH论文阅读/"},"frontmatter":{"title":"CRUSH论文阅读"}},"next":{"fields":{"slug":"/2022-07-25-Goland2022.01激活/"},"frontmatter":{"title":"IntelliJ Goland 2022.1.4 最新激活破解教程"}}},"pageContext":{"id":"019a283d-f02c-5e7c-a1b9-ca15a4684af6","previousPostId":"80fed25d-08f4-50d3-a481-1dfe174be084","nextPostId":"04b6e113-6f64-5770-bc03-b21d08d9a883"}},
    "staticQueryHashes": ["2841359383","3257411868"]}