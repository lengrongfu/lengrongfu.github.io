{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2019-05-07-file-save/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"5d47ad55-9e3c-58b3-a4db-40d5e5b9c664","excerpt":"存储系统简介 单机存储系统 分布式存储系统 Q&A 如何解决文件写入cache之后系统重启数据丢失的问题…","html":"<h1>存储系统简介</h1>\n<h1>单机存储系统</h1>\n<h1>分布式存储系统</h1>\n<h1>Q&#x26;A</h1>\n<h2>如何解决文件写入cache之后系统重启数据丢失的问题</h2>\n<h3>1、单节点</h3>\n<ul>\n<li>可以通过记录操作日志来进行恢复，使用<code class=\"language-text\">LVM</code>数据结构来顺序记录操作日志，然后顺序写入到磁盘，并且写成功了才能进行后续的操作。<code class=\"language-text\">Prometheus</code>、<code class=\"language-text\">leveldb</code>都是这也设计的，通过这种方式来解决缓存丢失的问题。</li>\n<li>定时把缓存刷新到磁盘，这里的缓存不论是操作系统的<code class=\"language-text\">Page cache</code>还是用户空间中的自定义缓存，都可以用这种方法，手动刷新缓存落地。</li>\n</ul>\n<h3>2、分布式</h3>\n<ul>\n<li>集群节点中可以通过副本的方式来保证一定有节点落地成功，典型应用<code class=\"language-text\">kafak</code>,<code class=\"language-text\">kafka</code>通过<code class=\"language-text\">mmap</code>内存映射文件技术，把用户态的内存映射到<code class=\"language-text\">Page cache</code>中去，节省了用户态缓存到<code class=\"language-text\">page cache</code>的复制时间，这样就会出现系统重启之后丢失数据问题，所以<code class=\"language-text\">kafak</code>一般配置为所有的副本分片都接收到了消息才认为成功，这样总有机器数据是完整的。副本也是现在很多分布式系统用的多的解决方案。</li>\n</ul>\n<h2>随机读写、顺序读写概念和性能问题</h2>\n<h3>1、随机读写</h3>\n<p>而每次随机读写的时候，寻道和旋转步骤都需要执行(不考虑操作系统读写缓冲)，并且随机读时缓存命中较低，这样就导致频繁的操作io，读取速度下降。对于随机读取的系统，设计是可以考虑进行<code class=\"language-text\">directio</code>,对文件进行直接读取。</p>\n<h3>2、顺序读写</h3>\n<p>在顺序读写的时候，寻道和旋转步骤只需要执行一次，剩下的全是数据传输所需要的固有开销。</p>\n<p><img src=\"2.png\" alt=\"测试结果\"></p>\n<h2>为什么kafka这么快</h2>\n<p>1、<code class=\"language-text\">kafka</code>写入数据时采用了顺序写入文件并且采用了<code class=\"language-text\">mmap</code>内存映射文件，可以减少一次<code class=\"language-text\">copy</code>，并且直接把数据写入到<code class=\"language-text\">page cache</code>中，操作系统再定期刷新到磁盘上去。这是<code class=\"language-text\">produce</code>写入快。\n2、<code class=\"language-text\">kafka</code>使用了<code class=\"language-text\">SendFile</code>技术，<code class=\"language-text\">DMA</code>引擎将文件中的数据拷贝到操作系统内核缓冲区中<code class=\"language-text\">page cache</code>，然后数据被拷贝到与<code class=\"language-text\">socket</code>相关的内核缓冲区。接下来，<code class=\"language-text\">DMA</code>引擎将数据从内核<code class=\"language-text\">socket</code>缓冲区中拷贝到协议引擎。这就是<code class=\"language-text\">consumer</code>速度快的原因，数据流直接从<code class=\"language-text\">page cache</code>发送到了<code class=\"language-text\">socket</code>的缓冲区中。</p>\n<h1>ssd相关的技术</h1>\n<h1>参考文章以及书籍</h1>\n<ul>\n<li><a href=\"https://www.cnkirito.moe/file-io-best-practise/\">文件IO操作的一些最佳实践</a></li>\n<li><a href=\"http://gao-xiao-long.github.io/2016/04/13/file-io/\">leveldb前奏—理解文件I/O</a></li>\n<li><a href=\"https://manbuyun.github.io/2017/01/13/%E4%B8%BA%E4%BB%80%E4%B9%88Kafka%E9%82%A3%E4%B9%88%E5%BF%AB/\">为什么Kafka那么快</a></li>\n<li><a href=\"https://m635674608.iteye.com/blog/2397068\">从Apache Kafka 重温文件高效读写</a></li>\n<li><a href=\"http://harlon.org/2018/06/20/database/\">深入理解MySQL底层实现</a></li>\n<li><a href=\"https://nvmexpress.org/resources/drivers/linux-driver-information/\">nvm</a></li>\n</ul>","frontmatter":{"title":"文件存储系统设计","date":"May 07, 2019","description":null}},"previous":{"fields":{"slug":"/2019-04-05-Introduction-to-Algorithms-lecture-2/"},"frontmatter":{"title":"渐进符号、替换、递归树、主方法"}},"next":{"fields":{"slug":"/2019-05-11-Introduction-to-Algorithms-lecture-7/"},"frontmatter":{"title":"散列表数据结构"}}},"pageContext":{"id":"5d47ad55-9e3c-58b3-a4db-40d5e5b9c664","previousPostId":"8315a56a-18c9-522c-a819-084676058a0c","nextPostId":"67c408f7-c082-5944-8970-a3fc2cd84293"}},
    "staticQueryHashes": ["2841359383","3257411868"]}