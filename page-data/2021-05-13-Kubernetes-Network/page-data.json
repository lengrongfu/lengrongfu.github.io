{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2021-05-13-Kubernetes-Network/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"4fb2782a-4ae1-5840-855f-812b9b344a1e","excerpt":"Kubernetes Network…","html":"<h1>Kubernetes Network</h1>\n<h2>一、单机容器网络</h2>\n<h3>名词</h3>\n<ul>\n<li>网络栈：网络栈包括了网卡(<code class=\"language-text\">Network Interface</code>)、回环设备(<code class=\"language-text\">Loopback Device</code>)、路由表(<code class=\"language-text\">Routing Table</code>)和<code class=\"language-text\">Iptables</code>规则，对于一个进程来说，这些要素，就构成了它发起请求和响应网络请求的基本环境。</li>\n<li>网桥(<code class=\"language-text\">Bridge</code>)：<code class=\"language-text\">bridge</code>是一个虚拟网络设备，所以具有网络设备的特征，可以配置<code class=\"language-text\">IP</code>、<code class=\"language-text\">MAC</code>地址；<code class=\"language-text\">Bridger</code>是一个虚拟交换机，具有和物理交换机类似的功能。它是工作在数据链路层的设备。</li>\n<li><code class=\"language-text\">Veth Pair</code>: 虚拟网线，用来连接容器到网桥上的；它被创建出来以后，总是以两张虚拟网卡(<code class=\"language-text\">Veth Peer</code>)的形式成对出现，并且，从其中一个网卡发出的数据包会自动出现在与之对应的网卡上，哪怕是这两张_*网卡_在不同的<code class=\"language-text\">Network Namespace</code>中。</li>\n<li><code class=\"language-text\">ARP</code>: 是一个通过三层的<code class=\"language-text\">IP</code>地址找到对应二层<code class=\"language-text\">MAC</code>地址的协议。</li>\n<li><code class=\"language-text\">CAM表</code>：虚拟交换机(这里是网桥)通过<code class=\"language-text\">MAC</code>地址学习维护的端口和<code class=\"language-text\">MAC</code>地址的对应表。</li>\n</ul>\n<h3>Host网络</h3>\n<p>作为一个容器，在启动时可以通过指定<code class=\"language-text\">-net=host</code>，使用宿主机的<code class=\"language-text\">Network Namespace</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker run -d -net=host --name nginx-1 nginx</code></pre></div>\n<p>使用<code class=\"language-text\">Host</code>网络的优点是网络性能较好，直接使用宿主机的网络栈，缺点是会引入共享网络资源的问题，比如端口冲突。<strong>所以，在多数情况下，我们都希望能使用自己Network Namespace里的网络栈，拥有属于自己的IP和端口。</strong></p>\n<h3>如何通信</h3>\n<p><img src=\"https://gitee.com/lengrongfu/blog-static-file/raw/master/single_node_container_network.png\" alt=\"单节点容器网络通信\"></p>\n<p>如上图，描述了单节点容器网络的通信流程，下面主要按<code class=\"language-text\">C1->C2</code>的访问流程来详细描述交互流程:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># 先创建两个容器，用于模拟发起请求,启动两个centos容器，并在里面安装net-tools工具，才可以使用ifconfig命令\n# 创建C1，并安装net-tools\n$ docker run -d -it --name c1 centos /bin/bash\n$ docker exec -it c1 bash\n$ [root@60671509044e /]# yum install -y net-tools\n# 创建C2，并安装net-tools\n$ docker run -d -it --name c2 centos /bin/bash\n$ docker exec -it c2 bash\n$ [root@94a6c877b01a /]# yum install -y net-tools</code></pre></div>\n<ul>\n<li>容器<code class=\"language-text\">C1</code>和<code class=\"language-text\">C2</code>启动之后，在容器中都有一条默认的路由规则，当前容器网段的所有请求都会走<code class=\"language-text\">eth0</code>网卡设备。\n<ul>\n<li>C1</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># 进入c1容器，查看ip以及路由表\n$ docker exec -it c1 bash\n# 查看IP\n$ ifconfig\neth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 172.17.0.7  netmask 255.255.0.0  broadcast 172.17.255.255\n        ether 02:42:ac:11:00:07  txqueuelen 0  (Ethernet)\n        RX packets 6698  bytes 9678058 (9.2 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 3518  bytes 195061 (190.4 KiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING>  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n# 查看路由       \n$ route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         _gateway        0.0.0.0         UG    0      0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</code></pre></div>\n<ul>\n<li><code class=\"language-text\">C2</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># 进入C2容器查看IP和路由表\n$ docker exec -it c2 bash\n$ ifconfig\neth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 172.17.0.8  netmask 255.255.0.0  broadcast 172.17.255.255\n        ether 02:42:ac:11:00:08  txqueuelen 0  (Ethernet)\n        RX packets 6771  bytes 9681937 (9.2 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 3227  bytes 179347 (175.1 KiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING>  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n# 查看路由\n$ route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         _gateway        0.0.0.0         UG    0      0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</code></pre></div>\n<p>上述容器现实有自己的<code class=\"language-text\">IP</code>以及<code class=\"language-text\">MAC</code>地址，并且每个容器中都有默认路由<code class=\"language-text\">_gateway</code>指向<code class=\"language-text\">eth0</code>网卡；并且<code class=\"language-text\">_gateway</code>有对应的<code class=\"language-text\">MAC</code>地址已经存在于本地<code class=\"language-text\">ARP</code>缓存中。</p>\n<ul>\n<li>主机之间网络通信需要用到<code class=\"language-text\">MAC</code>地址，这是数据链路层识别主机的方式，<code class=\"language-text\">C1</code>访问<code class=\"language-text\">C2</code>的时候会先从本地<code class=\"language-text\">ARP</code>缓存中查找是否有<code class=\"language-text\">C2</code>容器对应的<code class=\"language-text\">IP:172.17.0.3</code>的<code class=\"language-text\">MAC</code>地址。如果没有就会发起<code class=\"language-text\">ARP</code>协议查找<code class=\"language-text\">MAC</code>地址。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># c1 -> c2 ,先发起ARP请求查找MAC地址，可以在容器中查看ARP缓存对应IP的MAC\n$ docker exec -it c1 bash\n# 先查看本地的ARP缓存\n$ [root@94a6c877b01a /]# arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n_gateway                 ether   02:42:2e:8d:21:d6   C                     eth0\n# 执行ping命令就会发起ARP寻址请求\n$ ping 172.17.0.8\n# 再查询本地arp缓存，发现已经有MAC地址存在了\n$ [root@60671509044e /]# arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n172.17.0.8               ether   02:42:ac:11:00:08   C                     eth0\n_gateway                 ether   02:42:2e:8d:21:d6   C                     eth0</code></pre></div>\n<p><code class=\"language-text\">ARP</code>寻址流程：<code class=\"language-text\">C1</code>容器发起<code class=\"language-text\">ARP</code>请求，进过本地路由协议之后会把请求路由到网桥上，此时网桥(<code class=\"language-text\">Bridge</code>)充当一个虚拟交换机，虚拟交换机会把<code class=\"language-text\">ARP</code>广播到其它插入到网桥的所有容器，<code class=\"language-text\">C2</code>收到<code class=\"language-text\">ARP</code>协议之后会回复<code class=\"language-text\">MAC</code>地址。</p>\n<ul>\n<li>查找到<code class=\"language-text\">C2</code>的<code class=\"language-text\">MAC</code>地址之后就可以发起通信。</li>\n</ul>\n<h2>二、跨主机容器通信</h2>\n<blockquote>\n<p>跨主机之间容器通信按是否依赖底层网络环境来划分主要分为<code class=\"language-text\">Overlay</code>和<code class=\"language-text\">Underlay</code>两种网络结构，<code class=\"language-text\">Overlay</code>网络要求只是主机之间网络可达即可，不要求主机之间同处二层域；<code class=\"language-text\">Underlay</code>对底层的基础设施有要求，按照实现的方式对底层的网络基础设施有不同的要求，比如<code class=\"language-text\">Flanan host-gw</code>组件要求主机之间同处二层域，也就是主机之间要连接到一个交换机上。</p>\n</blockquote>\n<h4>名词</h4>\n<ul>\n<li><code class=\"language-text\">Overlay Network</code>(覆盖网络): 在已有的宿主机网络之上，通过软件构建一个覆盖在宿主机网络之上的、可以把所有容器连通在一起的虚拟网络。</li>\n<li><code class=\"language-text\">Tun设备(Tunnel设备)</code>：在<code class=\"language-text\">Linux</code>中，<code class=\"language-text\">TUN</code>设备是一种工作在三层（<code class=\"language-text\">Network Layer</code>）的虚拟网络设备;<code class=\"language-text\">Tun</code>设备的功能就是在操作系统内核和用户应用程序之间传递<code class=\"language-text\">IP</code>包，</li>\n<li><code class=\"language-text\">VXLAN</code>: 虚拟可扩展局域网(<code class=\"language-text\">Virtual Extensible LAN</code>),是<code class=\"language-text\">LINUX</code>内核支持的一种网络虚拟化技术，<code class=\"language-text\">VXLAN</code>完全在内核态实现网络数据包的封装和解封装。</li>\n<li><code class=\"language-text\">VTEP</code>：虚拟隧道端点设备，它既有<code class=\"language-text\">IP</code>，也有<code class=\"language-text\">MAC</code>地址。</li>\n<li><code class=\"language-text\">BGP</code>: 边界网关协议（<code class=\"language-text\">Border Gateway Protocol</code>）,它是一个<code class=\"language-text\">Linux</code>内核原生就支持的、专门用在大规模数据中心里维护不同的自治系统之间路由信息的、无中心的路由协议。</li>\n</ul>\n<h3>跨主机通信</h3>\n<p>跨主机之间的容器通信，通过采用<code class=\"language-text\">Overlay Network</code>来实现跨主机之间的容器通信，<code class=\"language-text\">Overlay Network</code>的实现有多种方式。</p>\n<p><img src=\"https://gitee.com/lengrongfu/blog-static-file/raw/master/overlay_network.png\" alt=\"Overlay Network\"></p>\n<h3>Overlay 模式</h3>\n<h5>1、三层Flannel UDP</h5>\n<blockquote>\n<p><code class=\"language-text\">Flannel UDP</code>模式是<code class=\"language-text\">Flannel</code>最开始提供的一种最简单且最易实现的容器跨主网络方案，但是因为性能最差，所以后来被弃用。但是对于理解<code class=\"language-text\">Overlay</code>的实现方式还是很有参考意义的。</p>\n</blockquote>\n<p>我们以一个例子来讲述这个网络访问的流程，在这个流程中，有两台宿主机，四个容器，我们需要通过<code class=\"language-text\">Container-1</code>容器请求<code class=\"language-text\">Container-4</code>。</p>\n<p><img src=\"https://gitee.com/lengrongfu/blog-static-file/raw/master/flannel_udp_network.png\" alt=\"\"></p>\n<p><code class=\"language-text\">Container-1</code>容器向<code class=\"language-text\">Container-4</code>容器发起请求，<code class=\"language-text\">Docker0</code>是位于<code class=\"language-text\">Root Network Namespace</code>的，通过<code class=\"language-text\">veth peer</code>一头连着容器的<code class=\"language-text\">Network Namespace</code>一头连着位于<code class=\"language-text\">Root Netwrok Namespace</code>的<code class=\"language-text\">Docker0</code>虚拟网络设备。</p>\n<ul>\n<li>容器<code class=\"language-text\">100.96.1.2</code>访问<code class=\"language-text\">100.96.2.2</code>，由于目的地址不在<code class=\"language-text\">Docker0</code>网桥的网段内(通过<code class=\"language-text\">ARP</code>请求一次就知道目标容器不在此网桥上)，所以这个<code class=\"language-text\">IP</code>会执行<code class=\"language-text\">Container-1</code>的默认路由规则中，容器中的默认路由规则就是如下的<code class=\"language-text\">default via 172.17.0.1 dev eth0 </code>。对应到上图的步骤1。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># 容器中默认设置的的路由规则，</span>\n<span class=\"token punctuation\">[</span>root@94a6c877b01a /<span class=\"token punctuation\">]</span><span class=\"token comment\"># ip route</span>\ndefault via <span class=\"token number\">172.17</span>.0.1 dev eth0 \n<span class=\"token number\">172.17</span>.0.0/16 dev eth0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">172.17</span>.0.2 \n<span class=\"token comment\"># 下一跳是172.17.0.1且从eth0设备上出去，通过查看docker的网络，172.17.0.1就是bridge设备的网关IP</span>\nlengrongfu@MacintoshdeMacBook-Pro ~ % docker network <span class=\"token function\">ls</span>        \nNETWORK ID     NAME                               DRIVER    SCOPE\ne522990979b3   bridge                             bridge    <span class=\"token builtin class-name\">local</span>\n<span class=\"token comment\"># 查看网络</span>\nlengrongfu@MacintoshdeMacBook-Pro ~ % docker inspect network e522990979b3\n<span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"Name\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"bridge\"</span>,\n        <span class=\"token string\">\"Id\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"e522990979b365e9df4d967c3600483e598e530361deb28513b6e75b8b66bedf\"</span>,\n        <span class=\"token string\">\"Created\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"2021-04-12T12:11:57.321486866Z\"</span>,\n        <span class=\"token string\">\"Scope\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"local\"</span>,\n        <span class=\"token string\">\"Driver\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"bridge\"</span>,\n        <span class=\"token string\">\"EnableIPv6\"</span><span class=\"token builtin class-name\">:</span> false,\n        <span class=\"token string\">\"IPAM\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"Driver\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"default\"</span>,\n            <span class=\"token string\">\"Options\"</span><span class=\"token builtin class-name\">:</span> null,\n            <span class=\"token string\">\"Config\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span>\n                <span class=\"token punctuation\">{</span>\n                    <span class=\"token string\">\"Subnet\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"172.17.0.0/16\"</span>,\n                    <span class=\"token string\">\"Gateway\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"172.17.0.1\"</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>,\n        <span class=\"token string\">\"Internal\"</span><span class=\"token builtin class-name\">:</span> false,\n        <span class=\"token string\">\"Attachable\"</span><span class=\"token builtin class-name\">:</span> false,\n        <span class=\"token string\">\"Ingress\"</span><span class=\"token builtin class-name\">:</span> false,\n        <span class=\"token string\">\"ConfigFrom\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"Network\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"\"</span>\n        <span class=\"token punctuation\">}</span>,\n        <span class=\"token string\">\"ConfigOnly\"</span><span class=\"token builtin class-name\">:</span> false,\n        <span class=\"token string\">\"Containers\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"94a6c877b01ac3a1638f1c5cde87e7c58be9ce0aafd4a78efcb96528ab00ed94\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token string\">\"Name\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"c2\"</span>,\n                <span class=\"token string\">\"EndpointID\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"a5c12fb3800991228f8dc3a2a8de1d6f4865439701a83558e4430c2aebf783a8\"</span>,\n                <span class=\"token string\">\"MacAddress\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"02:42:ac:11:00:02\"</span>,\n                <span class=\"token string\">\"IPv4Address\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"172.17.0.2/16\"</span>,\n                <span class=\"token string\">\"IPv6Address\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"\"</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>,\n        <span class=\"token string\">\"Options\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"com.docker.network.bridge.default_bridge\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"true\"</span>,\n            <span class=\"token string\">\"com.docker.network.bridge.enable_icc\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"true\"</span>,\n            <span class=\"token string\">\"com.docker.network.bridge.enable_ip_masquerade\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"true\"</span>,\n            <span class=\"token string\">\"com.docker.network.bridge.host_binding_ipv4\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"0.0.0.0\"</span>,\n            <span class=\"token string\">\"com.docker.network.bridge.name\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"docker0\"</span>,\n            <span class=\"token string\">\"com.docker.network.driver.mtu\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"1500\"</span>\n        <span class=\"token punctuation\">}</span>,\n        <span class=\"token string\">\"Labels\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<ul>\n<li>进入到<code class=\"language-text\">Docker0</code>网桥之后就按照主机上的路由取决于后续如何走。如下就是主机的路由表，访问目标<code class=\"language-text\">IP</code>为<code class=\"language-text\">100.96.2.2</code>的设备会命中第二条匹配规则，意思是访问<code class=\"language-text\">100.96.0.0/16</code>网段的数据去<code class=\"language-text\">flannel0</code>设备，并且愿<code class=\"language-text\">IP</code>为<code class=\"language-text\">100.96.1.0</code>。对应到上图的步骤2。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># Node1路由表</span>\n$ <span class=\"token function\">ip</span> route\n<span class=\"token number\">1</span> Default via <span class=\"token number\">10.168</span>.0.1 dev eth0\n<span class=\"token number\">2</span> <span class=\"token number\">100.96</span>.0.0/16 dev flannel0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">100.96</span>.1.0\n<span class=\"token number\">3</span> <span class=\"token number\">100.96</span>.1.0/24 dev docker0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">100.96</span>.1.1\n<span class=\"token number\">4</span> <span class=\"token number\">10.168</span>.0.0/24 dev eth0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">10.168</span>.0.2</code></pre></div>\n<h6>Flannel0设备</h6>\n<ul>\n<li>上述说了<code class=\"language-text\">Flannel0</code>是一个<code class=\"language-text\">TUN</code>虚拟三层网络设备，主要是在内核态和用户态之间传递<code class=\"language-text\">IP</code>包；继续按上述的流程分析，数据报文从内核态到达<code class=\"language-text\">Flannel0</code>设备之后，会被传递给创建<code class=\"language-text\">Flannel0</code>设备的进程也就是<code class=\"language-text\">FlannelD</code>进程，然后<code class=\"language-text\">flanneld</code>进程看到目的地址是<code class=\"language-text\">100.96.2.2</code>,就把数据报文发送到<code class=\"language-text\">Node2</code>节点上的<code class=\"language-text\">flanneld</code>进程监听的<code class=\"language-text\">UDP</code>端口上。<code class=\"language-text\">flanneld</code>会把要发送的数据封装为一个<code class=\"language-text\">UDP</code>数据包发出去。对应到上图的步骤3、4、5、6。\n<ul>\n<li><code class=\"language-text\">flanneld</code>进程是怎么知道<code class=\"language-text\">100.96.2.2</code>这个<code class=\"language-text\">ip</code>在<code class=\"language-text\">Node2</code>上呢，这是因为它利用了子网，在每个节点启动的时候都会被指定一个字网段，通过字网就能确定这个<code class=\"language-text\">ip</code>是属于那个节点的，子网被存在<code class=\"language-text\">etcd</code>里面。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">Node2</code>上的<code class=\"language-text\">flanneld</code>进程收到数据包之后，会发送到<code class=\"language-text\">flannel0</code>设备上，这是一个从用户态到内核态的过程，所以<code class=\"language-text\">Linux</code>内核网络协议栈就会负责处理这个<code class=\"language-text\">IP</code>包，具体的处理方法，就是通过本机的路由表来寻找这个<code class=\"language-text\">IP</code>包的下一步流向。对应到上图的步骤7、8。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># node2上的路由表</span>\n$ <span class=\"token function\">ip</span> route\n<span class=\"token number\">1</span> default via <span class=\"token number\">10.168</span>.0.1 dev eth0\n<span class=\"token number\">2</span> <span class=\"token number\">100.96</span>.0.0/16 dev flannel0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">100.96</span>.2.0\n<span class=\"token number\">3</span> <span class=\"token number\">100.96</span>.2.0/24 dev docker0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">100.96</span>.2.1\n<span class=\"token number\">4</span> <span class=\"token number\">10.168</span>.0.0/24 dev eth0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">10.168</span>.0.3</code></pre></div>\n<ul>\n<li>通过解析出目标<code class=\"language-text\">ip</code>为<code class=\"language-text\">100.96.2.2</code>，他和第三条的路由规则匹配更加精确，这条路由规则的意思是把发往<code class=\"language-text\">100.96.2.0/24</code>网段的的数据包发送到<code class=\"language-text\">docker0</code>设备上去，并且设置源<code class=\"language-text\">IP</code>为<code class=\"language-text\">100.96.2.1</code>。对应到上图的步骤9。</li>\n<li>数据包进入到<code class=\"language-text\">docker0</code>设备之后，<code class=\"language-text\">docker0</code>网桥会扮演二层交换机的角色，将数据包发送给正确的<code class=\"language-text\">veth pair</code>对，进过此设备之后就进入到<code class=\"language-text\">Contaniner-2</code>的网络协议栈中。对应到上图的步骤10。</li>\n</ul>\n<p><code class=\"language-text\">Flannel UDP</code>模式提供的是一个三层的<code class=\"language-text\">Overlay</code>网络，它首选对发出端的<code class=\"language-text\">IP</code>包进行<code class=\"language-text\">UDP</code>封装，然后在接收端进行解封装拿到原始<code class=\"language-text\">IP</code>包，进而把这个<code class=\"language-text\">IP</code>包转发给目标容器。</p>\n<p><code class=\"language-text\">Flannel UDP</code>模式有严重的性能问题，主要问题是，由于使用了<code class=\"language-text\">TUN</code>设备，仅在发出<code class=\"language-text\">IP</code>包的过程中，就需要经过三次用户态和内核态之间的数据拷贝。</p>\n<p><img src=\"https://gitee.com/lengrongfu/blog-static-file/raw/master/flannel_tun.png\" alt=\"tun\"></p>\n<h5>2、三层Calico ipip</h5>\n<h5>3、二层+三层VXLAN</h5>\n<blockquote>\n<p><code class=\"language-text\">VXLAN</code>网络的设计思想是，在现有的三层网络之上，覆盖一层虚拟的、由内核<code class=\"language-text\">VXLAN</code>模块负责维护的二层网络，使得连接在这个<code class=\"language-text\">VXLAN</code>二层网络上的主机之间，可以像在同一个局域网那样自由通信。</p>\n</blockquote>\n<blockquote>\n<p>为了能在二层网络上打通隧道，<code class=\"language-text\">VXLAN</code>会在宿主机上设置一个特殊的网络设备作为隧道的两端，这个设备就叫作<code class=\"language-text\">VTEP</code>，全称是：(<code class=\"language-text\">VXLAN Tun End Poin</code>)虚拟隧道端点。</p>\n</blockquote>\n<blockquote>\n<p><code class=\"language-text\">VTEP</code>设备的作用和<code class=\"language-text\">flanneld</code>进程的作用是一样的，就是做数据包的封装和解封装，只不过，它进行封装和解封装的是二层数据帧，而且这个工作流程，全都是在内核里完成的。</p>\n</blockquote>\n<h3>Underlay 模式</h3>\n<h5>1、三层模式BGP</h5>\n<p><img src=\"https://gitee.com/lengrongfu/blog-static-file/raw/master/bgp.png\" alt=\"BGP\"></p>\n<p>如上图是一个典型的<code class=\"language-text\">BGP</code>网络拓扑图，通过<code class=\"language-text\">Route1</code>和<code class=\"language-text\">Route2</code>作为边界路由网关，把其它<code class=\"language-text\">LAN</code>的路由信息写入到当前的路由中，就实现了不同<code class=\"language-text\">LAN</code>下的路由信息同步，达到三层网络全通。</p>\n<h6>Calico BGP 使用</h6>\n<p>​\t\t在了解了<code class=\"language-text\">BGP</code>之后，<code class=\"language-text\">Calico</code>项目的架构就非常容易理解了，它把每个主机节点当做一个边界路由来看待，所以在每个节点上都保存了所有其他节点的路由信息，我们来分析一下它的实现，它由三个部分组成：</p>\n<ul>\n<li><code class=\"language-text\">Calico</code>的<code class=\"language-text\">CNI</code>插件，这是<code class=\"language-text\">Caclico</code>和<code class=\"language-text\">Kubernetes</code>对接的部分。</li>\n<li><code class=\"language-text\">BIRD</code>是<code class=\"language-text\">BGP</code>的客户端，专门负责在集群里面分发路由信息。</li>\n<li><code class=\"language-text\">Felix</code>,它是一个<code class=\"language-text\">Demoset</code>，负责在宿主机上插入路由规则（写入<code class=\"language-text\">Linux</code>内核的<code class=\"language-text\">FIB</code>转发信息表），以及维护<code class=\"language-text\">Calico</code>所需的网络设备等工作。</li>\n</ul>\n<p>​\t<code class=\"language-text\">Calico BGP</code>模式和<code class=\"language-text\">Flannel host-gw</code>模式不同，<code class=\"language-text\">Calico</code>没有创建任何的虚拟网桥设备，<code class=\"language-text\">Calico</code>的工作方式采用如下图来说明。</p>\n<p><img src=\"https://gitee.com/lengrongfu/blog-static-file/raw/master/calico_bgp.png\" alt=\"calico_bgp\"></p>\n<p>​\t\t<code class=\"language-text\">Calico BGP</code>模式的网络交互图如上所示，如<code class=\"language-text\">container1</code>需要访问<code class=\"language-text\">Container3</code>，我们来分析下网络如何到达。因为没有采用<code class=\"language-text\">cni0</code>虚拟网桥设备，因此<code class=\"language-text\">veth</code>设备对的一端是在容器的<code class=\"language-text\">Network Namespace</code>中的，一端是在宿主机的容器网络空间的，</p>\n<ul>\n<li>首先<code class=\"language-text\">Calico CNI</code>插件还需要在每个宿主机上为每个容器的<code class=\"language-text\">Veth Pair</code>设备配置一条路由规则，由于接受传入的<code class=\"language-text\">IP</code>包，比如：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># 192.168.0.2节点上的路由信息有</span>\n$ <span class=\"token function\">ip</span> route\n<span class=\"token number\">10.20</span>.0.2 dev cali1 scope <span class=\"token function\">link</span>\n<span class=\"token number\">10.20</span>.0.3 dev cali2 scope <span class=\"token function\">link</span>\n\n<span class=\"token comment\"># 192.168.0.3节点上的路由信息有</span>\n$ <span class=\"token function\">ip</span> route\n<span class=\"token number\">10.20</span>.1.2 dev cali3 scope <span class=\"token function\">link</span>\n<span class=\"token number\">10.20</span>.1.3 dev cali4 scope <span class=\"token function\">link</span></code></pre></div>\n<ul>\n<li>每个节点上还有<code class=\"language-text\">BGP</code>广播的其它节点路由协议，比如：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># 192.168.0.2上有一条指向192.169.0.3的路由</span>\n$ <span class=\"token function\">ip</span> route\n<span class=\"token number\">10.20</span>.1.0/24 via <span class=\"token number\">192.168</span>.0.3 dev eth0\n<span class=\"token comment\"># 192.168.0.3上有一条指向192.168.0.2的路由</span>\n$ <span class=\"token function\">ip</span> route\n<span class=\"token number\">10.20</span>.0.0/24 via <span class=\"token number\">192.168</span>.0.2 dev eth0</code></pre></div>\n<ul>\n<li>默认的<code class=\"language-text\">Calico BGP</code>使用的是<code class=\"language-text\">Node to Node</code>的模式，会导致每个节点上的连接以<code class=\"language-text\">N^2</code>的数独增长，一般推荐少于使用<code class=\"language-text\">100</code>个节点的集群中。在大规模集群中，需要用到一个叫<code class=\"language-text\">Route Reflector</code>的模式，所有的路由会统一上报到一个中心节点，其它节点都从中心节点进行同步。</li>\n</ul>\n<p><code class=\"language-text\">Calico BGP</code>模式和<code class=\"language-text\">Flannel host-gw</code>模式一样，都有一个对基础网络设施的依赖，要求集群宿主机之间是二层可达的。假如宿主机之间处在不同的<code class=\"language-text\">LAN</code>下，就需要使用<code class=\"language-text\">Calico ipip</code>的<code class=\"language-text\">Overlay</code>模式了。</p>\n<h5>2、二层VLAN</h5>\n<h5>3、Flannel host-gw</h5>\n<blockquote>\n<p><code class=\"language-text\">Flannel host-gw</code>模式一张图就可以讲清楚他们之间的实现原理。</p>\n</blockquote>\n<p><img src=\"https://gitee.com/lengrongfu/blog-static-file/raw/master/flannel_hostgw.png\" alt=\"host-gw\"></p>\n<ul>\n<li><code class=\"language-text\">CNI0</code>设备是一个三层交换机，具有二层交换机的功能，同时具有独立<code class=\"language-text\">IP</code></li>\n</ul>\n<p><code class=\"language-text\">flannel</code>以<code class=\"language-text\">Daemonset</code>的方式在每个节点上启动一个<code class=\"language-text\">Flanneld</code>进程，用于维护每个节点上的路由信息，实现方式是，本地</p>\n<p>如：<code class=\"language-text\">192.168.1.0/24 via 10.20.0.3 dev eth0</code>路由定义了访问<code class=\"language-text\">192.168.1.0/24</code>网段的下一跳为<code class=\"language-text\">10.20.0.3</code>并从<code class=\"language-text\">eth0</code>设备出。</p>\n<p>然后<code class=\"language-text\">IP</code>包被封装成帧发送出去的时候，会使用路由表里的下一跳来设置目的<code class=\"language-text\">MAC</code>地址；这样，就能通过二层网络达到目的宿主机。</p>\n<p>因为他会使用下一跳的目的<code class=\"language-text\">MAC</code>地址，所以它要求宿主机之间是二层联通的，不如就没法通过使用<code class=\"language-text\">ARP</code>协议用<code class=\"language-text\">IP</code>去获取<code class=\"language-text\">MAC</code>地址了。</p>","frontmatter":{"title":"Kubernetes Network","date":"May 13, 2021","description":"Kubernetes Network 深入浅出"}},"previous":{"fields":{"slug":"/2021-05-12-文章全平台发布/"},"frontmatter":{"title":"文章全平台发布"}},"next":{"fields":{"slug":"/2021-05-15-断更的这段时间我去哪了/"},"frontmatter":{"title":"断更的这段时间我去哪了？"}}},"pageContext":{"id":"4fb2782a-4ae1-5840-855f-812b9b344a1e","previousPostId":"0834517d-2504-52d9-b23c-9c757272c267","nextPostId":"541faba3-cf16-5ff9-80c6-f0b1d024169b"}},
    "staticQueryHashes": ["2841359383","3257411868"]}