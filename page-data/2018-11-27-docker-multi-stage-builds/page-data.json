{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2018-11-27-docker-multi-stage-builds/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"4d797d0f-009f-5c44-b490-5300ac314230","excerpt":"…","html":"<blockquote>\n<p><code class=\"language-text\">docker</code>多阶段构建出现主要是为了解决一些在容器中进行编译工作，然后运行时容器只需要编译时容器的结果，不需要整个编译环境被依赖，减少镜像的大小。\n多阶段构建是从<code class=\"language-text\">docker</code>的<code class=\"language-text\">17.3</code>之后开始的，以前一个<code class=\"language-text\">Dockerfile</code>中只能有一个<code class=\"language-text\">FROM</code>指令，从多阶段构建出现之后就可以在一个<code class=\"language-text\">Dockerfile</code>中进行多个<code class=\"language-text\">FROM</code>的引用。</p>\n</blockquote>\n<h1>多阶段构建出现以前</h1>\n<blockquote>\n<p>在多阶段构建出现以前，需要单独写一个<code class=\"language-text\">Dockerfile</code>出来进行构建，然后再写一个<code class=\"language-text\">Dockerfile</code>来做运行时的镜像，再通过写一个脚步来把两个镜像的结果拼接起来。</p>\n</blockquote>\n<ul>\n<li>vim Dockerfile.build</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> golang:1.7.3</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /go/src/test/multi-stage-demo</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n<span class=\"token comment\">#RUN cd /test/multi-stage-demo</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .</span></code></pre></div>\n<ul>\n<li>vim Dockerfile.run</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> scratch</span>\n<span class=\"token comment\"># 多个文件copy</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> main <span class=\"token operator\">\\</span>\n     config.json <span class=\"token operator\">\\</span>\n     /root/</span>\n<span class=\"token comment\"># 暴露端口    </span>\n<span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 80</span>\n<span class=\"token comment\"># 运行</span>\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [ <span class=\"token string\">\"/root/main\"</span>,<span class=\"token string\">\"-conf=/root/config.json\"</span> ]</span></code></pre></div>\n<ul>\n<li>vim build.sh</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token shebang important\">#! /bin/bash</span>\n<span class=\"token builtin class-name\">echo</span> Building main:build\n<span class=\"token comment\"># 开始构建构建镜像</span>\ndocker build -t main:build -f Dockerfile.build <span class=\"token builtin class-name\">.</span>\n<span class=\"token comment\"># 创建构建容器，但是不运行，不能用run，run是包含了create和start两个命令</span>\ndocker container create --name extract main:build\n<span class=\"token comment\"># 复制容器中的两个文件</span>\ndocker container <span class=\"token function\">cp</span> extract:/go/src/test/multi-stage-demo/main ./main\ndocker container <span class=\"token function\">cp</span> extract:/go/src/test/multi-stage-demo/config.json ./config-run.json\n<span class=\"token comment\"># 删除创建的容器</span>\ndocker container <span class=\"token function\">rm</span> -f extract\n<span class=\"token comment\"># 删除构建镜像</span>\ndocker rmi main:build\n<span class=\"token builtin class-name\">echo</span> Building main:latest\n<span class=\"token comment\"># 开始构建运行时镜像</span>\ndocker build --no-cache -t main:latest <span class=\"token builtin class-name\">.</span>\n<span class=\"token comment\"># 删除拷贝到本地的文件</span>\n<span class=\"token function\">rm</span> ./main ./config-run.json\n<span class=\"token builtin class-name\">echo</span> Building Success.</code></pre></div>\n<p>通过上面的三个步骤就可以进行自动化的构建和打包运行时，但是这样比较麻烦，需要写<code class=\"language-text\">Dockerfile.build</code>和<code class=\"language-text\">Dockerfile.run</code>两个<code class=\"language-text\">Dockerfile</code>文件，还需要写一个构建脚本<code class=\"language-text\">build.sh</code>,最后通过运行脚本来打包镜像，这样比较麻烦，每个项目都需要维护多个文件。</p>\n<h1>多阶段构建出现以后</h1>\n<blockquote>\n<p>使用多阶段构建如上的步骤就非常简单</p>\n</blockquote>\n<ul>\n<li>vim Dockerfile</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># 第一步，构建</span>\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> golang:1.7.3 <span class=\"token keyword\">as</span> build</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /go/src/test/multi-stage-demo</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n<span class=\"token comment\">#RUN cd /test/multi-stage-demo</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .</span>\n<span class=\"token comment\"># 第二部，运行</span>\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> scratch</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">build</span></span> /go/src/test/multi-stage-demo/main <span class=\"token operator\">\\</span>\n                 /go/src/test/multi-stage-demo/config.json <span class=\"token operator\">\\</span>\n                 /go/src/test/multi-stage-demo/docker-entrypoint.sh <span class=\"token operator\">\\</span>\n                /root/</span>\n<span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 80</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [ <span class=\"token string\">\"/root/main\"</span>,<span class=\"token string\">\"-conf=/root/config.json\"</span> ]</span>\n</code></pre></div>\n<p>上面主要是第二步比较陌生，<code class=\"language-text\">COPY</code>命令中的<code class=\"language-text\">--from=build</code>是指从构建阶段中复制文件。而不是当前的上下文中，所以复制的路径需要指定为第一个阶段构建结果存储的路径。<code class=\"language-text\">--from=0</code>也可以这样写，这样就不需要给第一步一个别名，直接这样写就行了，<code class=\"language-text\">FROM golang:1.7.3</code>。其他的都是和正常的<code class=\"language-text\">Dockerfile</code>没有区别的。</p>\n<p>通过<code class=\"language-text\">docker build -t main .</code>就可以进行如上的打包。</p>\n<h1>golang 项目中多阶段构建依赖问题</h1>\n<p><code class=\"language-text\">Golang</code>项目如果没有使用<code class=\"language-text\">vender</code>进行管理的话，使用多阶段构建就会出现问题，前提是有依赖其他第三方包，因为在<code class=\"language-text\">Copy</code>的时候只会把当前项目下的文件复制进构建容器中，而复制不到项目之外的文件，打包的时候就会因为找不到依赖包而打包不成功，比如一个项目使用了<code class=\"language-text\">uber</code>的日志包<code class=\"language-text\">\"go.uber.org/zap\"</code>,但是打包的时候会因为找不到依赖包构建不通过。不建议在构建时再去拉取这些依赖包，这样可能会出现开发和生产上使用的依赖包代码不一致的问题。\n针对上述问题目前我想到的两个办法时：</p>\n<ul>\n<li>1、修改构建的上下文，改为<code class=\"language-text\">src</code>,把<code class=\"language-text\">Golang</code>的本地的<code class=\"language-text\">src</code>都复制进容器中去构建，这样能通过，但是只能用于个人，公司项目一般都是有单独的服务器进行构建。这样可能会比较大。</li>\n<li>2、使用<code class=\"language-text\">dep</code>管理，就是<code class=\"language-text\">Golang</code>的包管理工具，把依赖包都集成到项目的<code class=\"language-text\">vender</code>中来，这样打包的时候就能找到依赖包。我认为这样时比较好的办法，而且对开发也方便，便于依赖包的统一管理。</li>\n</ul>\n<h1>多阶段构建适用的场景</h1>\n<p>一般只有需要依赖有单独的编译环境的项目使用多阶段构建才比较适合，比如前端的项目，需要使用<code class=\"language-text\">node</code>进行编译，这样就可以写一个编译容器出来进行单独的编译。</p>\n<p><code class=\"language-text\">Golang</code>和<code class=\"language-text\">Docker</code>集成工具 <a href=\"https://github.com/drone/drone\">drone</a>.</p>\n<h1>参考</h1>\n<ul>\n<li>项目源码路径：<a href=\"https://github.com/lengrongfu/multi-stage-demo/tree/master\">https://github.com/lengrongfu/multi-stage-demo/tree/master</a></li>\n<li>use-multi-stage-builds：<a href=\"https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds\">https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds</a></li>\n</ul>","frontmatter":{"title":"docker 多阶段构建","date":"November 27, 2018","description":null}},"previous":{"fields":{"slug":"/2018-11-25-docker-network-concept/"},"frontmatter":{"title":"docker 网络概念"}},"next":{"fields":{"slug":"/2018-12-05-Container-Networking-Standards/"},"frontmatter":{"title":"Container Networking 标准"}}},"pageContext":{"id":"4d797d0f-009f-5c44-b490-5300ac314230","previousPostId":"eb6e54fc-fbb2-5f58-a9cc-e8e1a2810b12","nextPostId":"3fde9505-a374-52f7-920f-a8808a63848f"}},
    "staticQueryHashes": ["2841359383","3257411868"]}