{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2021-12-25 gRPC 学习之初级知识/",
    "result": {"data":{"site":{"siteMetadata":{"title":"LRF"}},"markdownRemark":{"id":"ba3c9598-4f9e-5dac-a758-7415e9c7d46e","excerpt":"初级知识 1、进程间通信 同步请求的响应风格 异步请求的事件驱动风格 请求响应的风格最常见和传统的方式就是构建为RESTful 服务，但是，使用RESTful 服务来实现进程间通信显得过于笨重、低效并且容易出错。 2、进程间通信技术的演进 传统的RPC： 早期有一些流行的RPC…","html":"<h2>初级知识</h2>\n<h3>1、进程间通信</h3>\n<ul>\n<li>同步请求的响应风格</li>\n<li>异步请求的事件驱动风格</li>\n</ul>\n<p>请求响应的风格最常见和传统的方式就是构建为RESTful 服务，但是，使用RESTful 服务来实现进程间通信显得过于笨重、低效并且容易出错。</p>\n<h3>2、进程间通信技术的演进</h3>\n<ul>\n<li>传统的RPC：</li>\n</ul>\n<blockquote>\n<p>早期有一些流行的RPC实现，比如通用对象请求代理体系结构CORBA和 Java 的远程调用(remot method invocation, RMI)；但是，他们的实现极其复杂，因为他们是构建在TCP这样的通信协议之上。</p>\n</blockquote>\n<ul>\n<li>SOAP</li>\n</ul>\n<blockquote>\n<p>鉴于CORBA等传统RPC实现的局限性，简单对象访问协议（SOAP）就产生了，SOAP是面向服务的架构（SOA）中的标准通信技术，能够基于任意的底层通信协议进行通信，其中最常用的就是HTTP。</p>\n</blockquote>\n<ul>\n<li>RESTFul</li>\n</ul>\n<blockquote>\n<p>描述性状态迁移 (REST) 是面向资源的架构的基础，在这种架构中，需要将分布式应用程序建模为资源集合，访问这些资源的客户端可以变更这些资源的状态（创建、修改、删除）。RUST 的通用实现是 HTTP。</p>\n<p>随着微服务的数量及其网络交互的激增，RESTFul 服务已经无法慢煮现代化的需求了，下面介绍 3 个主要的局限性：</p>\n<ol>\n<li>基于文本的低效消息协议：RESTFul 服务建立在基于文本的传输协议之上，并且会使用人类可读的文本格式，如 JSON。</li>\n<li>应用程序之间缺乏强类型接口：越来越多的服务要通过网络进行交互，而且这些服务使用完全不同的语言来构建，缺乏明确定义和强类型的服务接口成了使用RESTFul 服务的主要障碍。</li>\n<li>REST 架构风格难以强制实施：REST 架构风格有很多好的实践，只有遵循这些实践，才能构建出真正的 RESTFul 服务；但是，由于没有作为实现协议（如：HTTP）的一部分强制要求，因此，在实践阶段，这些实践难以实施。</li>\n</ol>\n</blockquote>\n<h3>3、gRPC 的起源</h3>\n<p>来源于 Google 的 Stubby 的通用 RPC 框架。2015 年 Google 发布了 Stubby 的社区版本 gRPC 框架，并捐献给了 CNCF 社区。</p>\n<h3>4、gRPC 的优势</h3>\n<ul>\n<li>提供高效的进程间通信。</li>\n</ul>\n<blockquote>\n<ol>\n<li>gRPC 没有使用类似 JSON 、 XML 之类的文本传输协议，而是采用自定义的  <code class=\"language-text\">protocol buffers </code> 的二进制协议。</li>\n<li>gRPC 在 HTTP/2 上实现了 protocol buffers 的协议。</li>\n</ol>\n</blockquote>\n<ul>\n<li>具有简单且定义良好的服务接口和模式</li>\n</ul>\n<blockquote>\n<p>gRPC 为应用提供了必须先定义接口，才能去处理细节的要求，gRPC 为应用提供了简单但一致，可靠且可扩展的应用程序。</p>\n<p>解决了类似 REST 模式需要遵循好的架构风格实践，才能构建出真正的 RESTFul 服务，但是 gRPC 自带类似的好的架构风格。</p>\n</blockquote>\n<ul>\n<li>属于强类型</li>\n</ul>\n<blockquote>\n<p>通过定义应用服务之间通信所使用的类型，对于其所产生的大多数运行时错误和互操作错误，可以通过静态类型来克服。</p>\n</blockquote>\n<ul>\n<li>支持多语言</li>\n</ul>\n<blockquote>\n<p>gRPC 支持多语言，基于 protocol buffers 定义的服务时语言中立的。</p>\n</blockquote>\n<ul>\n<li>支持双工流</li>\n</ul>\n<blockquote>\n<p>gRPC 客户端和服务端都提供了对流的原生支持。</p>\n</blockquote>\n<ul>\n<li>具备内置的商业化特性</li>\n</ul>\n<blockquote>\n<p>gRPC 提供了商业化特性的内置支持，如<strong>认证、加密、弹性、元数据交换、压缩、负载均衡、服务发现</strong>等。</p>\n</blockquote>\n<ul>\n<li>与云原生系统进行了集成</li>\n</ul>\n<blockquote>\n<p>gRPC 是 CNCF 的一部分，大多数框架和技术都对 gRPC 提供了原生的支持。</p>\n<p>同时提供了丰富的应用性能监控工具。如 metrics、tracing、logging。</p>\n</blockquote>\n<h3>5、gRPC 的劣势</h3>\n<ul>\n<li>gRPC 不太适合面向外部的服务</li>\n</ul>\n<blockquote>\n<p>gRPC 服务具有契约精神、强类型等特点，会限制暴露外部服务的灵活性，同时消费者的控制权会削弱很多。gRPC 网关是克服该问题的解决方案。</p>\n</blockquote>\n<ul>\n<li>大的服务变更是复杂的开发流程</li>\n</ul>\n<blockquote>\n<p>gRPC 服务出现变更，需要重新生成客户端和服务端代码。</p>\n</blockquote>\n<ul>\n<li>gRPC 系统相对较小</li>\n</ul>\n<blockquote>\n<p>与 REST 和 HTTP 等协议相比，gRPC 的生态系统相对较小。</p>\n</blockquote>\n<h3>6、gRPC 基本使用</h3>","frontmatter":{"title":"gRPC 学习之-初级知识","date":"December 25, 2021","description":"我把 `gRPC`  共划分为四个级别来学习，有浅入深的展开，对应不同阶段的人进行学习。"}},"previous":{"fields":{"slug":"/2021-05-26-启航/"},"frontmatter":{"title":"启航"}},"next":{"fields":{"slug":"/2021-12-30 gRPC 学习之中级知识/"},"frontmatter":{"title":"gRPC 学习之-中级知识"}}},"pageContext":{"id":"ba3c9598-4f9e-5dac-a758-7415e9c7d46e","previousPostId":"ace99f43-060d-5228-95de-c3fcf20fdaf5","nextPostId":"6599b40c-659d-546e-a496-bc5dfd06a04b"}},
    "staticQueryHashes": ["2841359383","3257411868"]}